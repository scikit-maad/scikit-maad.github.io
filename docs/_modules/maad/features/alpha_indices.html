

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>maad.features.alpha_indices &mdash; scikit-maad 1.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> scikit-maad
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart</a></li>
</ul>
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sound.html">Sound processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rois.html">Segmentation methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Acoustic features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spl.html">Sound pressure level</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../util.html">Utilities</a></li>
</ul>
<p class="caption"><span class="caption-text">Example Gallery</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_auto_examples/index.html">Example gallery</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">scikit-maad</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>maad.features.alpha_indices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for maad.features.alpha_indices</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">Collection of functions to compute alpha acoustic indices to chracterise audio signals.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1"># Authors:  Juan Sebastian ULLOA &lt;lisofomia@gmail.com&gt;</span>
<span class="c1">#           Sylvain HAUPERT &lt;sylvain.haupert@mnhn.fr&gt;        </span>
<span class="c1">#</span>
<span class="c1"># License: New BSD License</span>

<span class="c1">#%%</span>
<span class="c1">#***************************************************************************</span>
<span class="c1"># -------------------       Load modules         ---------------------------</span>
<span class="c1">#***************************************************************************</span>
<span class="c1"># Import external modules</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">abs</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">var</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">opening</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">binary_erosion</span><span class="p">,</span> <span class="n">binary_dilation</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rankdata</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> <span class="c1"># for csv</span>
<span class="c1"># min value</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">_MIN_</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span>

<span class="c1"># Import internal modules</span>
<span class="kn">from</span> <span class="nn">maad.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">rle</span><span class="p">,</span> <span class="n">index_bw</span><span class="p">,</span> <span class="n">amplitude2dB</span><span class="p">,</span> <span class="n">power2dB</span><span class="p">,</span> <span class="n">dB2power</span><span class="p">,</span> <span class="n">mean_dB</span><span class="p">,</span>
                       <span class="n">skewness</span><span class="p">,</span> <span class="n">kurtosis</span><span class="p">,</span> <span class="n">format_features</span><span class="p">,</span> <span class="n">into_bins</span><span class="p">,</span> <span class="n">entropy</span><span class="p">,</span> 
                       <span class="n">linear_scale</span><span class="p">,</span> <span class="n">plot1d</span><span class="p">,</span> <span class="n">plot2d</span><span class="p">,</span> <span class="n">overlay_rois</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">maad.spl</span> <span class="kn">import</span> <span class="n">wav2leq</span><span class="p">,</span> <span class="n">psd2leq</span><span class="p">,</span> <span class="n">power2dBSPL</span>
<span class="kn">from</span> <span class="nn">maad.features</span> <span class="kn">import</span> <span class="p">(</span><span class="n">centroid_features</span><span class="p">,</span> <span class="n">zero_crossing_rate</span><span class="p">,</span> <span class="n">temporal_moments</span><span class="p">,</span> 
                           <span class="n">spectral_moments</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">maad.sound</span> <span class="kn">import</span> <span class="p">(</span><span class="n">envelope</span><span class="p">,</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">temporal_snr</span><span class="p">,</span> <span class="n">linear_to_octave</span><span class="p">,</span> 
                        <span class="n">avg_amplitude_spectro</span><span class="p">,</span> <span class="n">avg_power_spectro</span><span class="p">,</span> <span class="n">spectral_snr</span><span class="p">,</span> 
                        <span class="n">median_equalizer</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">maad.rois</span> <span class="kn">import</span> <span class="n">select_rois</span><span class="p">,</span> <span class="n">create_mask</span>

<span class="c1">#%%</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Private functions</span>
<span class="c1"># =============================================================================</span>
<span class="k">def</span> <span class="nf">_acoustic_activity</span> <span class="p">(</span><span class="n">xdB</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Acoustic Activity [1]_:</span>
<span class="sd">    </span>
<span class="sd">    for each frequency bin :</span>
<span class="sd">    - ACTfract : proportion (fraction) of points above the threshold </span>
<span class="sd">    - ACTcount : number of points above the threshold</span>
<span class="sd">    - ACTmean : mean value (in dB) of the portion of the signal above the threhold</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xdB : ndarray of floats</span>
<span class="sd">        1d : envelope in dB of the audio signal </span>
<span class="sd">        2d : PSD spectrogram in dB</span>
<span class="sd">        It&#39;s better to work with PSD or envelope without background variation</span>
<span class="sd">        as the process is based on threshold.</span>
<span class="sd">    dB_threshold : scalar, optional, default is 6dB</span>
<span class="sd">        data &gt;Threshold is considered to be an event </span>
<span class="sd">        if the length is &gt; rejectLength</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    ACTfract :ndarray of scalars</span>
<span class="sd">        proportion (fraction) of points above the threshold for each frequency bin</span>
<span class="sd">    ACTcount: ndarray of scalars</span>
<span class="sd">        number of points above the threshold for each frequency bin</span>
<span class="sd">    ACTmean: scalar</span>
<span class="sd">        mean value (in dB) of the portion of the signal above the threhold</span>
<span class="sd">        </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Towsey, Michael (2013), Noise Removal from Waveforms and Spectrograms Derived </span>
<span class="sd">    from Natural Recordings of the Environment. Queensland University of Technology, Brisbane.</span>
<span class="sd">    </span>
<span class="sd">    ACTsp [Towsey] : ACTfract (proportion (fraction) of point value above the theshold)</span>
<span class="sd">    EVNsp [Towsey] : ACTcount (number of point value above the theshold)</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1">### For x to be a ndarray</span>
    <span class="n">xdB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xdB</span><span class="p">)</span>
   
    <span class="c1">### compute _score</span>
    <span class="n">ACTfract</span><span class="p">,</span> <span class="n">ACTcount</span> <span class="o">=</span> <span class="n">_score</span><span class="p">(</span><span class="n">xdB</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ACTfract</span><span class="o">=</span> <span class="n">ACTfract</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">ACTcount</span> <span class="o">=</span> <span class="n">ACTcount</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">ACTmean</span> <span class="o">=</span> <span class="n">mean_dB</span><span class="p">(</span><span class="n">xdB</span><span class="p">[</span><span class="n">xdB</span><span class="o">&gt;</span><span class="n">dB_threshold</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ACTfract</span><span class="p">,</span> <span class="n">ACTcount</span><span class="p">,</span> <span class="n">ACTmean</span> 

<span class="c1">#%%    </span>
<span class="k">def</span> <span class="nf">_acoustic_events</span><span class="p">(</span><span class="n">xdB</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">rejectDuration</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Acoustic events [1]_ :</span>
<span class="sd">        - EVNsum : total events duration (s) </span>
<span class="sd">        - EVNmean : mean events duration (s)</span>
<span class="sd">        - EVNcount : number of events per s</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xdB : ndarray of floats</span>
<span class="sd">        2d : Spectrogram  in dB</span>

<span class="sd">    dt : scalar</span>
<span class="sd">        Time resolution</span>

<span class="sd">    dB_threshold : scalar, optional, default is 6dB</span>
<span class="sd">        data &gt;Threshold is considered to be an event </span>
<span class="sd">        if the length is &gt; rejectLength</span>
<span class="sd">        </span>
<span class="sd">    rejectDuration : scalar, optional, default is None</span>
<span class="sd">        event shorter than rejectDuration are discarded</span>
<span class="sd">        duration is in s</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    EVNsum :scalar</span>
<span class="sd">        total events duration in s</span>
<span class="sd">    EVNmean: scalar</span>
<span class="sd">        mean events duration in s</span>
<span class="sd">    EVNcount: scalar</span>
<span class="sd">        number of events per s</span>
<span class="sd">    EVN: ndarray of floats </span>
<span class="sd">        binary vector or matrix.</span>
<span class="sd">        1 corresponds to event</span>
<span class="sd">        0 corresponds to background</span>

<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1]  Towsey, Michael (2013), Noise Removal from Waveforms and Spectrograms </span>
<span class="sd">            Derived from Natural Recordings of the Environment. </span>
<span class="sd">            Queensland University of Technology, Brisbane.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># total duration</span>
    <span class="k">if</span> <span class="n">xdB</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span><span class="mi">1</span> <span class="p">:</span> <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xdB</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="n">xdB</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span><span class="mi">2</span> <span class="p">:</span> <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">xdB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    
    <span class="n">xdB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xdB</span><span class="p">)</span>
    <span class="c1"># thresholding =&gt; binary</span>
    <span class="n">EVN</span> <span class="o">=</span> <span class="p">(</span><span class="n">xdB</span><span class="o">&gt;=</span><span class="n">dB_threshold</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>  
    <span class="c1"># Remove events shorter than &#39;rejectLength&#39; </span>
    <span class="c1"># (done by erosion+dilation = opening)</span>
    <span class="k">if</span> <span class="n">rejectDuration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rejectLength</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">rejectDuration</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="c1"># tricks. Depending on the dimension of bin_x </span>
        <span class="c1"># if bin_x is a vector</span>
        <span class="k">if</span> <span class="n">EVN</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">rejectLength</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># if bin_x is a matrix</span>
        <span class="k">elif</span> <span class="n">EVN</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">kernel</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">rejectLength</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>  
        <span class="k">else</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;xdB must be a vector or a matrix&quot;</span><span class="p">)</span>
        <span class="c1"># Morphological tool : Opening</span>
        <span class="n">EVN</span> <span class="o">=</span> <span class="n">binary_erosion</span><span class="p">(</span><span class="n">EVN</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">EVN</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">EVN</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">kernel</span><span class="p">)</span> 
    
    <span class="c1"># Extract the characteristics of each event : </span>
    <span class="c1"># duration (mean and sum in s) and count</span>
    <span class="k">if</span> <span class="n">EVN</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
        <span class="n">EVNsum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">EVNmean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">EVNcount</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EVN</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rle</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">v</span><span class="o">==</span><span class="mi">1</span><span class="p">])</span><span class="o">!=</span><span class="mi">0</span> <span class="p">:</span>
                <span class="c1"># mean events duration in s</span>
                <span class="n">EVNmean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">v</span><span class="o">==</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">EVNmean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    
            <span class="c1"># total events duration in s </span>
            <span class="n">EVNsum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">v</span><span class="o">==</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
            <span class="c1"># number of events</span>
            <span class="n">EVNcount</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span> <span class="n">duration</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">EVN</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rle</span><span class="p">(</span><span class="n">EVN</span><span class="p">)</span> 
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">v</span><span class="o">==</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span><span class="mi">0</span> <span class="p">:</span>
            <span class="c1"># mean events duration in s</span>
            <span class="n">EVNmean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">v</span><span class="o">==</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">EVNmean</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># total events duration in s </span>
        <span class="n">EVNsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">v</span><span class="o">==</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="c1"># number of events per s</span>
        <span class="n">EVNcount</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">duration</span>
    <span class="k">else</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;xdB must be a vector or a matrix&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">EVNsum</span><span class="p">,</span> <span class="n">EVNmean</span><span class="p">,</span> <span class="n">EVNcount</span><span class="p">,</span> <span class="n">EVN</span>

<span class="c1">#%%</span>
<span class="k">def</span> <span class="nf">_score</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Score</span>

<span class="sd">    count the number of times values in x that are greater than the threshold </span>
<span class="sd">    and normalized by the total number of values in x</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray of floats</span>
<span class="sd">        Vector or matrix containing the data</span>
<span class="sd">        </span>
<span class="sd">    threshold : scalar</span>
<span class="sd">        Value &gt; threshold are counted    </span>
<span class="sd">        </span>
<span class="sd">    axis : integer, optional, default is 0</span>
<span class="sd">        score is calculated along this axis.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    count : scalar</span>
<span class="sd">        the number of times values in x that are greater than the threshold</span>
<span class="sd">    s : scalar</span>
<span class="sd">        count is normalized by the total number of values in x</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">threshold</span>
    <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span>

<span class="c1">#%%</span>
<span class="k">def</span> <span class="nf">_shannonEntropy</span><span class="p">(</span><span class="n">datain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shannon Entropy</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    datain : ndarray of floats</span>
<span class="sd">        Vector or matrix containing the data</span>
<span class="sd">    </span>
<span class="sd">    axis : integer, optional, default is 0</span>
<span class="sd">        entropy is calculated along this axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    Hs : ndarray of floats</span>
<span class="sd">        Vector or matrix of Shannon Entropy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># length of datain along axis</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">datain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">Hs</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">datain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Hs</span>

<span class="c1">#%%</span>
<span class="k">def</span> <span class="nf">_gini</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gini</span>
<span class="sd">    </span>
<span class="sd">    Compute the Gini value of x</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray of floats</span>
<span class="sd">        Vector or matrix containing the data</span>
<span class="sd">    </span>
<span class="sd">    corr : boolean, optional, default is False</span>
<span class="sd">        Correct the Gini value</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------  </span>
<span class="sd">    G: scalar</span>
<span class="sd">        Gini value</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Ported from ineq library in R</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
       <span class="n">G</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># null gini</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">G</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">G</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">corr</span> <span class="p">:</span> <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">/</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span> <span class="n">G</span><span class="o">=</span> <span class="n">G</span><span class="o">/</span><span class="n">n</span>
    <span class="k">return</span> <span class="n">G</span>

<span class="c1">#%%</span>
<span class="k">def</span> <span class="nf">_raoQ</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Rao&#39;s Quadratic entropy in 1d</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    p : ndarray of floats (1d)</span>
<span class="sd">        a vector containing the probality of each bin</span>
<span class="sd">    bins : ndarray of floats (1d)</span>
<span class="sd">        a vector containing the value of each bin</span>
<span class="sd">        </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    Q : scalar</span>
<span class="sd">        Rao&#39;s Quadratic entropy value</span>
<span class="sd">    </span>
<span class="sd">    Reference:</span>
<span class="sd">    ---------</span>
<span class="sd">    .. [1] Botta-Dukát, Zoltán, Rao’s quadratic entropy as a measure of functional </span>
<span class="sd">    diversity based on multiple traits, Journal of Vegetation Science, 2005</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># be sure they are ndarray</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    
    <span class="c1"># Normalize p by the sum in order to get the sum of p = 1</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
    <span class="c1"># Bins is normalized by the bins range</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="o">/</span><span class="p">(</span><span class="n">bins</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">bins</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    
    <span class="c1"># take advantage of broadcasting, </span>
    <span class="c1"># Get the pairwise distance </span>
    <span class="c1"># Euclidian distance</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        
    <span class="c1"># compute the crossproduct of pixels value pi,pj</span>
    <span class="n">pipj</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>

    <span class="c1"># Multiply by 2*sqrt(2) to take into account the lower triangle (symmetric)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pipj</span><span class="o">*</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">Q</span>

<span class="c1">#%%</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Public functions</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="surface_roughness"><a class="viewcode-back" href="../../../generated/maad.features.surface_roughness.html#maad.features.surface_roughness">[docs]</a><span class="k">def</span> <span class="nf">surface_roughness</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span><span class="s1">&#39;global&#39;</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the surface roughness index of a signal (1D) or a spectrogram (2D).</span>
<span class="sd">    </span>
<span class="sd">    Surface roughness is quantified by the deviations in the direction of the normal </span>
<span class="sd">    vector of a real surface from its ideal form. If these deviations are large, </span>
<span class="sd">    the surface is rough; if they are small, the surface is smooth [1]_.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray of floats</span>
<span class="sd">        vector (1d) or matrix (2d)</span>
<span class="sd">    </span>
<span class="sd">    norm : string, optional, default is &#39;global&#39;</span>
<span class="sd">        Determine if the ROUGHNESS is normalized by the sum of the whole data</span>
<span class="sd">        (&#39;global&#39; mode) or by the sum of horizontal line for each line</span>
<span class="sd">        (&#39;per_bin&#39;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------                </span>
<span class="sd">    Ra : scalar or 1d ndarray of scalars</span>
<span class="sd">        if x is a vector =&gt; Arithmetical mean deviation of x.</span>
<span class="sd">        if x is a matrix =&gt; Arithmetical mean deviation of each line of x.</span>
<span class="sd">        </span>
<span class="sd">    Rq : scalar or 1d ndarray of scalars</span>
<span class="sd">        if x is a vector =&gt; Root mean squared of deviationn of x.</span>
<span class="sd">        if x is a matrix =&gt; Root mean squared of deviation of each line of x.</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, https://en.wikipedia.org/wiki/Surface_roughness</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># force to be ndarray</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">m</span>
        <span class="c1"># Arithmetic mean deviation</span>
        <span class="n">Ra</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="c1"># Root mean square</span>
        <span class="n">Rq</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  
        
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span><span class="mi">2</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;per_bin&#39;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">m</span> 
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span> <span class="p">(</span><span class="s1">&#39;norm has to be in {per_bin, global}&#39;</span><span class="p">)</span>    
        
        <span class="c1"># Arithmetic mean deviation</span>
        <span class="n">Ra</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Root mean square</span>
        <span class="n">Rq</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>   
        
    <span class="k">else</span> <span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span> <span class="p">(</span><span class="s1">&#39;x should be a vector (1d) or a matrix (2d) of floats&#39;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">Rq</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="roughness"><a class="viewcode-back" href="../../../generated/maad.features.roughness.html#maad.features.roughness">[docs]</a><span class="k">def</span> <span class="nf">roughness</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the roughness (depends on the number of peaks and their amplitude)</span>
<span class="sd">    of a vector or matrix x (i.e. waveform, spectrogram...)   </span>
<span class="sd">    Roughness = sum(second_derivation(x)²)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray of floats</span>
<span class="sd">        x is a vector (1d) or a matrix (2d)</span>
<span class="sd">        </span>
<span class="sd">    norm : boolean, optional. Default is None</span>
<span class="sd">    </span>
<span class="sd">        - &#39;global&#39; : normalize by the maximum value in the vector or matrix</span>
<span class="sd">        - &#39;per_axis&#39; : normalize by the maximum value found along each axis</span>

<span class="sd">    axis : int, optional, default is 0</span>
<span class="sd">        select the axis where the second derivation is computed</span>
<span class="sd">        </span>
<span class="sd">        if x is a vector, axis=0</span>
<span class="sd">        </span>
<span class="sd">        if x is a 2d ndarray, axis=0 =&gt; rows, axis=1 =&gt; columns</span>
<span class="sd">                </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : float or ndarray of floats</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Described in [Ramsay JO, Silverman BW (2005) Functional data analysis.]</span>
<span class="sd">    Ported from SEEWAVE R Package</span>
<span class="sd">    &quot;&quot;&quot;</span>      
    
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;per_axis&#39;</span> <span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> 
            <span class="n">m</span><span class="p">[</span><span class="n">m</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_MIN_</span>    <span class="c1"># Avoid dividing by zero value</span>
            <span class="k">if</span> <span class="n">axis</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">m</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
            <span class="k">elif</span> <span class="n">axis</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">m</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span> <span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_MIN_</span>    <span class="c1"># Avoid dividing by zero value</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">m</span> 
            
    <span class="n">deriv2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">deriv2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">r</span></div>


<span class="c1">#******************************************************************************</span>
<span class="c1">#               TEMPORAL ECOACOUSTICS INDICES</span>
<span class="c1">#******************************************************************************</span>
<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="temporal_median"><a class="viewcode-back" href="../../../generated/maad.features.temporal_median.html#maad.features.temporal_median">[docs]</a><span class="k">def</span> <span class="nf">temporal_median</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the median of the envelope of an audio signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : 1D array</span>
<span class="sd">        Audio to process (wav)</span>
<span class="sd">    mode : str, optional, default is &quot;fast&quot;</span>
<span class="sd">        Select the mode to compute the envelope of the audio waveform</span>
<span class="sd">        - &quot;fast&quot; : The sound is first divided into frames (2d) using the </span>
<span class="sd">            function _wave2timeframes(s), then the max of each frame gives a </span>
<span class="sd">            good approximation of the envelope.</span>
<span class="sd">        - &quot;Hilbert&quot; : estimation of the envelope from the Hilbert transform. </span>
<span class="sd">            The method is slow</span>
<span class="sd">    Nt : integer, optional, default is 512</span>
<span class="sd">        Size of each frame. The largest, the highest is the approximation.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    MED: float</span>
<span class="sd">       Median of the envelope </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; med = maad.features.temporal_median(s)</span>
<span class="sd">    &gt;&gt;&gt; print(med)</span>
<span class="sd">    0.007934564717486147</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Envelope</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="n">Nt</span><span class="p">)</span>
    <span class="c1"># median</span>
    <span class="n">MED</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">MED</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="temporal_entropy"><a class="viewcode-back" href="../../../generated/maad.features.temporal_entropy.html#maad.features.temporal_entropy">[docs]</a><span class="k">def</span> <span class="nf">temporal_entropy</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">compatibility</span><span class="o">=</span><span class="s2">&quot;QUT&quot;</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the entropy of the envelope of an audio signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : 1D array</span>
<span class="sd">        Audio to process (wav)</span>
<span class="sd">    compatibility : string {&#39;QUT&#39;, &#39;seewave&#39;}, default is &#39;QUT&#39;</span>
<span class="sd">        Select the way to compute the temporal entropy.</span>
<span class="sd">            - QUT [2]_: entropy of the squared envelope</span>
<span class="sd">            - seewave [1]_ : entropy of the envelope</span>
<span class="sd">    mode : str, optional, default is &quot;fast&quot;</span>
<span class="sd">        Select the mode to compute the envelope of the audio waveform.</span>
<span class="sd">            - &quot;fast&quot; : The sound is first divided into frames (2d) using the function _wave2timeframes(s), then the max of each frame gives a good approximation of the envelope.</span>
<span class="sd">            - &quot;Hilbert&quot; : estimation of the envelope from the Hilbert transform. The method is slow.</span>
<span class="sd">    Nt : integer, optional, default is 512</span>
<span class="sd">        Size of each frame. The largest, the highest is the approximation.</span>
<span class="sd">   </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ht: float</span>
<span class="sd">       Temporal entropy of the audio </span>
<span class="sd">       </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Seewave : http://rug.mnhn.fr/seewave/</span>
<span class="sd">    Sueur, J., Aubin, T., &amp; Simonis, C. (2008). Seewave, a free modular tool </span>
<span class="sd">    for sound analysis and synthesis. Bioacoustics, 18(2), 213-226.</span>
<span class="sd">     </span>
<span class="sd">    .. [2] QUT : https://github.com/QutEcoacoustics/audio-analysis/</span>
<span class="sd">    Michael Towsey, Anthony Truskinger, Mark Cottman-Fields, &amp; Paul Roe. </span>
<span class="sd">    (2018, March 5). Ecoacoustics Audio Analysis Software v18.03.0.41 (Version v18.03.0.41). </span>
<span class="sd">    Zenodo. http://doi.org/10.5281/zenodo.1188744</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The entropy of an audio signal is a measure of energy dispersion. In the temporal domain, </span>
<span class="sd">    values below 0.7 indicate a brief concentration of energy (few miliseconds), while </span>
<span class="sd">    values close 1 indicate low concentration of energy, no peaks, smooth and constant </span>
<span class="sd">    background noise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Ht = maad.features.temporal_entropy (s)</span>
<span class="sd">    &gt;&gt;&gt; print(Ht)</span>
<span class="sd">    0.7518917279549968</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Envelope</span>
    <span class="n">env</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="n">Nt</span><span class="p">)</span>
    <span class="c1"># Entropy</span>
    <span class="k">if</span> <span class="n">compatibility</span> <span class="o">==</span> <span class="s1">&#39;QUT&#39;</span><span class="p">:</span>
        <span class="n">Ht</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">env</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">compatibility</span> <span class="o">==</span> <span class="s1">&#39;seewave&#39;</span><span class="p">:</span>
        <span class="n">Ht</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;compatibility must be selected in {QUT, seewave}&#39;</span><span class="p">)</span>  

    <span class="k">return</span> <span class="n">Ht</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="acoustic_richness_index"><a class="viewcode-back" href="../../../generated/maad.features.acoustic_richness_index.html#maad.features.acoustic_richness_index">[docs]</a><span class="k">def</span> <span class="nf">acoustic_richness_index</span> <span class="p">(</span><span class="n">Ht_array</span><span class="p">,</span> <span class="n">M_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the acoustic richness index of an audio file. </span>
<span class="sd">    </span>
<span class="sd">    This acoustic index was first described in [1]_. The present version was </span>
<span class="sd">    translated from the R software package Seewave [2]_.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ht_array : 1d ndarray of floats</span>
<span class="sd">        Vector containing the temporal entropy Ht of the selected files </span>
<span class="sd">    M_array: 1d ndarray of floats</span>
<span class="sd">        Vector containing the amplitude index M  of the selected files </span>

<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    AR : 1d ndarray of floats</span>
<span class="sd">        Vector of acoustic richenss index</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Depraetere, M., Pavoine, S., Jiguet, F., Gasc, A., Duvail, S., &amp; Sueur, J. (2012). Monitoring animal diversity using acoustic indices: Implementation in a temperate woodland. Ecological Indicators, 13, 46–54.</span>
<span class="sd">    .. [2] Sueur, J., Aubin, T., &amp; Simonis, C. (2008). Seewave: A free modular tool for sound analysis and synthesis. Bioacoustics, 18, 213–226.</span>

<span class="sd">    Examples:</span>
<span class="sd">    ---------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/indices/S4A03895_20190522_060000.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Ht_6h00 = maad.features.temporal_entropy(s)</span>
<span class="sd">    &gt;&gt;&gt; M_6h00 = maad.features.temporal_median(s)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/indices/S4A03895_20190522_080000.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Ht_8h00= maad.features.temporal_entropy(s)</span>
<span class="sd">    &gt;&gt;&gt; M_8h00 = maad.features.temporal_median(s)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/indices/S4A03895_20190522_100000.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Ht_10h00 = maad.features.temporal_entropy(s)</span>
<span class="sd">    &gt;&gt;&gt; M_10h00 = maad.features.temporal_median(s)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; maad.features.acoustic_richness_index([Ht_6h00,Ht_8h00,Ht_10h00],</span>
<span class="sd">                                              [M_6h00,M_8h00,M_10h00])</span>
<span class="sd">    array([0.11111111, 0.44444444, 1.        ])</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ht_array</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">M_array</span><span class="p">)</span> <span class="p">:</span> 
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;warning : Ht_array and M_array must have the same length&quot;</span><span class="p">)</span>
    
    <span class="n">AR</span> <span class="o">=</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">Ht_array</span><span class="p">)</span> <span class="o">*</span> <span class="n">rankdata</span><span class="p">(</span><span class="n">M_array</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ht_array</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="k">return</span> <span class="n">AR</span></div>

<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="temporal_activity"><a class="viewcode-back" href="../../../generated/maad.features.temporal_activity.html#maad.features.temporal_activity">[docs]</a><span class="k">def</span> <span class="nf">temporal_activity</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="mi">512</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the acoustic activity index in temporal domain.</span>
<span class="sd">    </span>
<span class="sd">    Acoustic activity corresponds to the portion of the waveform above a </span>
<span class="sd">    threshold [1]_</span>
<span class="sd">    Three values are computed with this function:</span>
<span class="sd">        - ACTfract : proportion (fraction) of points above the threshold </span>
<span class="sd">        - ACTcount : number of points above the threshold</span>
<span class="sd">        - ACTmean : mean value (in dB) of the portion of the signal above the threhold</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : 1D array of floats</span>
<span class="sd">        audio to process (wav)</span>
<span class="sd">    dB_threshold : scalar, optional, default is 3dB</span>
<span class="sd">        data &gt;Threshold is considered to be an activity </span>
<span class="sd">    mode : str, optional, default is &quot;fast&quot;</span>
<span class="sd">        Select the mode to compute the envelope of the audio waveform</span>
<span class="sd">        - &quot;fast&quot; : The sound is first divided into frames (2d) using the </span>
<span class="sd">            function _wave2timeframes(s), then the max of each frame gives a </span>
<span class="sd">            good approximation of the envelope.</span>
<span class="sd">        - &quot;Hilbert&quot; : estimation of the envelope from the Hilbert transform. </span>
<span class="sd">            The method is slow</span>
<span class="sd">    Nt : integer, optional, default is 512</span>
<span class="sd">        Size of each frame. The largest, the highest is the approximation.    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    ACTfract :ndarray of scalars</span>
<span class="sd">        proportion (fraction) of points above the threshold for each frequency bin</span>
<span class="sd">    ACTcount: ndarray of scalars</span>
<span class="sd">        number of points above the threshold for each frequency bin</span>
<span class="sd">    ACTmean: scalar</span>
<span class="sd">        mean value (in dB) of the portion of the signal above the threhold</span>
<span class="sd">        </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Towsey, Michael (2013), Noise Removal from Waveforms and Spectrograms Derived </span>
<span class="sd">    from Natural Recordings of the Environment. Queensland University of Technology, Brisbane.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ACTfract, ACTcount, ACTmean = maad.features.temporal_activity (s, 6)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;ACTfract: %2.2f / ACTcount: %2.0f / ACTmean: %2.2f&#39; % (ACTfract, ACTcount, ACTmean))</span>
<span class="sd">    ACTfract: 0.37 / ACTcount: 620 / ACTmean: 24.41</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="c1">### For wave to be a ndarray</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
    
    <span class="c1">### envelope</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="p">:</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="n">Nt</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;hilbert&#39;</span> <span class="p">:</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hilbert&#39;</span><span class="p">)</span>

    <span class="c1">### get background value</span>
    <span class="n">_</span><span class="p">,</span><span class="n">BGNt</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">temporal_snr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>
    
    <span class="c1"># linear to power dB</span>
    <span class="n">envdB</span> <span class="o">=</span> <span class="n">amplitude2dB</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    
    <span class="c1"># subtract the background noise</span>
    <span class="n">envdB</span> <span class="o">=</span> <span class="n">envdB</span> <span class="o">-</span> <span class="n">BGNt</span>
    
    <span class="n">ACTtFraction</span><span class="p">,</span> <span class="n">ACTtCount</span><span class="p">,</span> <span class="n">ACTtMean</span> <span class="o">=</span> <span class="n">_acoustic_activity</span> <span class="p">(</span><span class="n">envdB</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ACTtFraction</span><span class="p">,</span> <span class="n">ACTtCount</span><span class="p">,</span> <span class="n">ACTtMean</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="temporal_events"><a class="viewcode-back" href="../../../generated/maad.features.temporal_events.html#maad.features.temporal_events">[docs]</a><span class="k">def</span> <span class="nf">temporal_events</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">rejectDuration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                  <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">Nt</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the acoustic event index from an audio signal.</span>
<span class="sd">    </span>
<span class="sd">    An acoustic event corresponds to the period of the signal above a </span>
<span class="sd">    threshold. An acoustic event could be short (at list one point if </span>
<span class="sd">    rejectDuration is None) or very long (the duration of the entire audio). </span>
<span class="sd">    Two acoustic events are separated by a period with low audio signal (ie</span>
<span class="sd">    below the threshold)</span>
<span class="sd">    Four values are computed with this function:</span>
<span class="sd">        - EVNtFraction : Fraction: events duration over total duration</span>
<span class="sd">        - EVNmean : mean events duration (s)</span>
<span class="sd">        - EVNcount : number of events per s</span>
<span class="sd">        - EVN : binary vector or matrix with 1 corresponding to event position</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : 1D array of floats</span>
<span class="sd">        audio to process (wav)</span>
<span class="sd">    fs : Integer</span>
<span class="sd">        sampling frequency in Hz</span>
<span class="sd">    dB_threshold : scalar, optional, default is 3dB</span>
<span class="sd">        data &gt;Threshold is considered to be an event </span>
<span class="sd">        if the length is &gt; rejectLength</span>
<span class="sd">    rejectDuration : scalar, optional, default is None</span>
<span class="sd">        event shorter than rejectDuration are discarded</span>
<span class="sd">        duration is in s</span>
<span class="sd">    mode : str, optional, default is &quot;fast&quot;</span>
<span class="sd">        Select the mode to compute the envelope of the audio waveform</span>
<span class="sd">        - &quot;fast&quot; : The sound is first divided into frames (2d) using the </span>
<span class="sd">            function _wave2timeframes(s), then the max of each frame gives a </span>
<span class="sd">            good approximation of the envelope.</span>
<span class="sd">        - &quot;Hilbert&quot; : estimation of the envelope from the Hilbert transform. </span>
<span class="sd">            The method is slow</span>
<span class="sd">    Nt : integer, optional, default is 512</span>
<span class="sd">        Size of each frame. The largest, the highest is the approximation.</span>
<span class="sd">    display : boolean, optional, default is False</span>
<span class="sd">        Display the selected events on the audio waveform</span>
<span class="sd">    \*\*kwargs, optional. </span>
<span class="sd">        This parameter is used by plt.plot</span>

<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    EVNtFraction :scalar</span>
<span class="sd">        Fraction: events duration over total duration</span>
<span class="sd">    EVNmean: scalar</span>
<span class="sd">        mean events duration in s</span>
<span class="sd">    EVNcount: scalar</span>
<span class="sd">        number of events per s</span>
<span class="sd">    EVN: ndarray of floats </span>
<span class="sd">        binary vector or matrix.</span>
<span class="sd">        1 corresponds to event</span>
<span class="sd">        0 corresponds to background</span>

<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Towsey, Michael (2013), Noise Removal from Waveforms and Spectrograms Derived </span>
<span class="sd">    from Natural Recordings of the Environment. Queensland University of Technology, Brisbane.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; EVNtFract, EVNmean, EVNcount, _ = maad.features.temporal_events (s, fs, 6)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;EVNtFract: %2.2f / EVNmean: %2.2f / EVNcount: %2.0f&#39; % (EVNtFract, EVNmean, EVNcount))</span>
<span class="sd">    EVNtFract: 0.37 / EVNmean: 0.08 / EVNcount:  5</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="c1">### For wave to be a ndarray</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
    
    <span class="c1">### envelope</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="p">:</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="o">*</span><span class="n">Nt</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;hilbert&#39;</span> <span class="p">:</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">envelope</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span>
    
    <span class="c1"># Time vector</span>
    <span class="n">tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    
    <span class="c1">### get background value</span>
    <span class="n">_</span><span class="p">,</span><span class="n">BGNt</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">temporal_snr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>
    
    <span class="c1"># linear to power dB</span>
    <span class="n">envdB</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">env</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># subtract the background noise</span>
    <span class="n">envdB</span> <span class="o">=</span> <span class="n">envdB</span> <span class="o">-</span> <span class="n">BGNt</span>
    
    <span class="n">EVNtSum</span><span class="p">,</span> <span class="n">EVNtMean</span><span class="p">,</span> <span class="n">EVNtCount</span><span class="p">,</span> <span class="n">EVNt</span> <span class="o">=</span> <span class="n">_acoustic_events</span> <span class="p">(</span><span class="n">envdB</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="p">,</span> <span class="n">rejectDuration</span><span class="o">=</span><span class="n">rejectDuration</span><span class="p">)</span>
    
    <span class="c1"># EVNtFraction</span>
    <span class="n">EVNtFraction</span> <span class="o">=</span> <span class="n">EVNtSum</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">tn</span><span class="p">))</span>
    
    <span class="c1">### display</span>
    <span class="k">if</span> <span class="n">display</span> <span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="n">env</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">env</span><span class="p">)),</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EVNt</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Detected Events&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>   
    
    <span class="k">return</span> <span class="n">EVNtFraction</span><span class="p">,</span> <span class="n">EVNtMean</span><span class="p">,</span> <span class="n">EVNtCount</span><span class="p">,</span> <span class="n">EVNt</span></div>


<span class="c1">#******************************************************************************</span>
<span class="c1">#               FREQUENCY ECOACOUSTICS INDICES</span>
<span class="c1">#******************************************************************************</span>

<div class="viewcode-block" id="frequency_entropy"><a class="viewcode-back" href="../../../generated/maad.features.frequency_entropy.html#maad.features.frequency_entropy">[docs]</a><span class="k">def</span> <span class="nf">frequency_entropy</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">compatibility</span><span class="o">=</span><span class="s2">&quot;QUT&quot;</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the spectral entropy of a power spectral density (1d) or power</span>
<span class="sd">    spectrogram density (2d).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : 1D or 2D array</span>
<span class="sd">        Power Spectral/Spectrogram Density (PSD) of an audio</span>
<span class="sd">        Better to work with PSD (amplitude¹) than with amplitude for energy </span>
<span class="sd">        conservation</span>
<span class="sd">    compatibility : string {&#39;QUT&#39;, &#39;seewave&#39;}, default is &#39;QUT&#39;</span>
<span class="sd">        Select the way to compute the spectral entropy.</span>
<span class="sd">            - QUT [2]_ : entropy of P</span>
<span class="sd">            - seewave [1]_ : entropy of sqrt(P)   </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Hf: float</span>
<span class="sd">       spectral entropy of the audio </span>
<span class="sd">    Ht_per_bin : array of floats</span>
<span class="sd">        temporal entropy along time axis for each frequency when P is a </span>
<span class="sd">        spectrogram (2d) otherwise Ht_per_bin is empty   </span>
<span class="sd">       </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Seewave : http://rug.mnhn.fr/seewave/</span>
<span class="sd">    Sueur, J., Aubin, T., &amp; Simonis, C. (2008). Seewave, a free modular tool </span>
<span class="sd">    for sound analysis and synthesis. Bioacoustics, 18(2), 213-226.</span>
<span class="sd">     </span>
<span class="sd">    .. [2] QUT : https://github.com/QutEcoacoustics/audio-analysis/</span>
<span class="sd">    Michael Towsey, Anthony Truskinger, Mark Cottman-Fields, &amp; Paul Roe. </span>
<span class="sd">    (2018, March 5). Ecoacoustics Audio Analysis Software v18.03.0.41 (Version v18.03.0.41). </span>
<span class="sd">    Zenodo. http://doi.org/10.5281/zenodo.1188744</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The spectral entropy of a signal measures the energy dispersion along frequencies. Low values </span>
<span class="sd">    indicates a concentration of energy around a narrow frequency band. </span>
<span class="sd">    If the DC value is not removed before processing the large peak at f=0Hz will </span>
<span class="sd">    lower the entropy of the signal.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,_,_,_ = maad.sound.spectrogram (s, fs)   </span>
<span class="sd">    &gt;&gt;&gt; Hf, Ht_per_bin = maad.features.frequency_entropy(Sxx_power)</span>
<span class="sd">    &gt;&gt;&gt; print(Hf)</span>
<span class="sd">    0.6313982665877063</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Length of Ht_per_bin is : %2.0f&#39; % len(Ht_per_bin))</span>
<span class="sd">    Length of Ht_per_bin is : 512</span>
<span class="sd">    &gt;&gt;&gt; print(Ht_per_bin)</span>
<span class="sd">    [0.73458664 0.73476487 0.87981728 0.9161413  0.90153962 0.91684881</span>
<span class="sd">     0.91816039 0.93453925 0.92958317 0.93763948 0.93524745 0.93736222...]</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Force to be an array</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="c1"># test if P has 2 dimension (i.e a spectrogram Pxx)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span>
        <span class="c1"># Entropy</span>
        <span class="k">if</span> <span class="n">compatibility</span> <span class="o">==</span> <span class="s1">&#39;QUT&#39;</span><span class="p">:</span>
            <span class="n">Hf</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">Ht_per_bin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">compatibility</span> <span class="o">==</span> <span class="s1">&#39;seewave&#39;</span><span class="p">:</span>
            <span class="n">Hf</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
            <span class="n">Ht_per_bin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;compatibility must be selected in {QUT, seewave}&#39;</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span> <span class="p">:</span>     
        <span class="c1"># Entropy</span>
        <span class="k">if</span> <span class="n">compatibility</span> <span class="o">==</span> <span class="s1">&#39;QUT&#39;</span><span class="p">:</span>
            <span class="n">Hf</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1"># P is a spectrogram, computes entropy along time axis for each frequency</span>
            <span class="n">Ht_per_bin</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="n">compatibility</span> <span class="o">==</span> <span class="s1">&#39;seewave&#39;</span><span class="p">:</span>
            <span class="n">Hf</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
            <span class="c1"># P is a spectrogram, computes entropy along time axis for each frequency</span>
            <span class="n">Ht_per_bin</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;compatibility must be selected in {QUT, seewave}&#39;</span><span class="p">)</span>             
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;P must be a spectrum (1d) or a spectrogram (2d)&#39;</span><span class="p">)</span>    
    
    <span class="k">return</span> <span class="n">Hf</span><span class="p">,</span> <span class="n">Ht_per_bin</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="number_of_peaks"><a class="viewcode-back" href="../../../generated/maad.features.number_of_peaks.html#maad.features.number_of_peaks">[docs]</a><span class="k">def</span> <span class="nf">number_of_peaks</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;dB&#39;</span><span class="p">,</span> <span class="n">min_peak_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_freq_dist</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> 
                  <span class="n">slopes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the number of frequency peaks on a mean spectrum.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of floats (1d) or (2d)</span>
<span class="sd">        Amplitude spectrum (1d) or spectrogram (2d). If spectrogram, the mean</span>
<span class="sd">        spectrum will be computed before finding peaks</span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        frequency vector</span>
<span class="sd">    mode : string {dB, linear}, optional, default is dB</span>
<span class="sd">        select if the amplitude spectrum is converted into dB </span>
<span class="sd">    min_peak_val : scalar, optional, default is None</span>
<span class="sd">        amplitude threshold parameter. Only peaks above this threshold will be </span>
<span class="sd">        considered.</span>
<span class="sd">    min_freq_dist: scalar, optional, default is 200 </span>
<span class="sd">        frequency threshold parameter (in Hz). </span>
<span class="sd">        If the frequency difference of two successive peaks is less than this threshold, </span>
<span class="sd">        then the peak of highest amplitude will be kept only.</span>
<span class="sd">    slopes : tupple of two values, optional, default is (1,1)   </span>
<span class="sd">        slope parameter, tupple of float of length 2 corresponding to left and </span>
<span class="sd">        right slopes, one or both could be set to None.</span>
<span class="sd">        Refers to the amplitude slopes of the peak. </span>
<span class="sd">        The first value is the left slope and the second value is the right slope. </span>
<span class="sd">        Only peaks with higher slopes than threshold values will be kept. </span>
<span class="sd">    display: boolean, optional, default is False</span>
<span class="sd">        if True, display the mean spectrum with the detected peaks</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NBPeaks : integer</span>
<span class="sd">        Number of detected peaks on the mean spectrum</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Gasc, A. &amp; al (2013). Biodiversity sampling using a global acoustic </span>
<span class="sd">    approach: contrasting sites with microendemics in New Caledonia. </span>
<span class="sd">    PloS one, 8(5), e65311.</span>
<span class="sd">    </span>
<span class="sd">    Inspired by the function `fpeaks` from the R package Seewave.</span>
<span class="sd">    .. [2] Sueur, J., Aubin, T., &amp; Simonis, C. (2008). Seewave: A free modular tool for sound </span>
<span class="sd">    analysis and synthesis. Bioacoustics, 18, 213–226.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power, tn, fn, _ = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; maad.features.number_of_peaks(Sxx_power, fn, slopes=6, min_freq_dist=100, display=True) </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Force to be an array</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="c1"># mean spectrum</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">avg_amplitude_spectro</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">X</span>
    
    <span class="c1"># if mode is &quot;dB&quot;, convert into dB</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span> <span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">amplitude2dB</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_peak_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">min_peak_val</span> <span class="o">=</span> <span class="n">amplitude2dB</span><span class="p">(</span><span class="n">min_peak_val</span><span class="p">)</span>

    <span class="c1"># Find peaks</span>
    <span class="n">min_pix_distance</span> <span class="o">=</span> <span class="n">min_freq_dist</span><span class="o">/</span><span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">index</span><span class="p">,</span> <span class="n">prop</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">min_peak_val</span><span class="p">,</span> 
                             <span class="n">distance</span> <span class="o">=</span> <span class="n">min_pix_distance</span><span class="p">,</span> 
                             <span class="n">prominence</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># keep peaks with with slopes higher than the limit</span>
    <span class="k">if</span> <span class="n">slopes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">index_select</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slopes</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="p">:</span>
        <span class="n">left_slope</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]]</span>
        <span class="n">index_select</span> <span class="o">=</span> <span class="n">index</span><span class="p">[(</span><span class="n">left_slope</span><span class="o">&gt;=</span><span class="n">slopes</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">slopes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>   <span class="p">:</span>
            <span class="n">left_slope</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]]</span>
            <span class="n">right_slope</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span>
            <span class="n">index_select</span> <span class="o">=</span> <span class="n">index</span><span class="p">[(</span><span class="n">left_slope</span><span class="o">&gt;=</span><span class="n">slopes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">right_slope</span><span class="o">&gt;</span><span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">left_slope</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;left_bases&#39;</span><span class="p">]]</span>
            <span class="n">index_select</span> <span class="o">=</span> <span class="n">index</span><span class="p">[(</span><span class="n">left_slope</span><span class="o">&gt;=</span><span class="n">slopes</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">right_slope</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;right_bases&#39;</span><span class="p">]]</span>
            <span class="n">index_select</span> <span class="o">=</span> <span class="n">index</span><span class="p">[(</span><span class="n">right_slope</span><span class="o">&gt;</span><span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_select</span> <span class="o">=</span> <span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">index_select</span> <span class="o">=</span> <span class="n">index</span>
    
    <span class="c1"># number of peaks</span>
    <span class="n">NBPeaks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_select</span><span class="p">)</span>
    
    <span class="c1"># display</span>
    <span class="k">if</span> <span class="n">display</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span> <span class="p">:</span>
            <span class="n">ylabel</span> <span class="o">=</span><span class="s1">&#39;Amplitude [dB]&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;Amplitude [AU]&#39;</span>
        <span class="n">fig_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="s1">&#39;figtitle&#39;</span><span class="p">:</span><span class="s1">&#39;Mean Spectrum with detected peaks&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;xlabel&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xlabel&#39;</span><span class="p">,</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">),</span>
                      <span class="s1">&#39;ylabel&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ylabel&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="p">)</span>
                      <span class="p">}</span>

        <span class="n">ax</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">plot1d</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">fig_kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="n">index_select</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">index_select</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mec</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> 
                <span class="n">mew</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">NBPeaks</span></div>


<span class="c1">#=============================================================================</span>

<span class="c1">####    Indices based on the entropy</span>

<div class="viewcode-block" id="spectral_entropy"><a class="viewcode-back" href="../../../generated/maad.features.spectral_entropy.html#maad.features.spectral_entropy">[docs]</a><span class="k">def</span> <span class="nf">spectral_entropy</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">flim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute different entropies based on the average spectrum, its variance, </span>
<span class="sd">    and its maxima [1]_     </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx : ndarray of floats</span>
<span class="sd">        Spectrogram (2d). </span>
<span class="sd">        It is recommended to work with PSD to be consistent with energy conservation</span>
<span class="sd">    </span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        frequency vector</span>
<span class="sd">    </span>
<span class="sd">    flim : tupple (fmin, fmax), optional, default is None</span>
<span class="sd">        Frequency band used to compute the spectral entropy.</span>
<span class="sd">        For instance, one may want to compute the spectral entropy for the </span>
<span class="sd">        biophony bandwidth</span>
<span class="sd">    </span>
<span class="sd">    display : boolean, optional, default is False</span>
<span class="sd">        Display the different spectra (mean, variance, covariance, max...)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------     </span>
<span class="sd">    EAS : scalar</span>
<span class="sd">        Entropy of Average Spectrum</span>
<span class="sd">    ECU : scalar</span>
<span class="sd">        Entropy of spectral variance (along the time axis for each frequency)</span>
<span class="sd">    ECV : scalar</span>
<span class="sd">        Entropy of Coefficient of Variation (along the time axis for each frequency)</span>
<span class="sd">    EPS : scalar</span>
<span class="sd">        Entropy of spectral maxima (peaks) </span>
<span class="sd">    EPS_KURT : scalar</span>
<span class="sd">        Kurtosis of spectral maxima</span>
<span class="sd">    EPS_SKEW : scalar</span>
<span class="sd">        Skewness of spectral maxima</span>
<span class="sd">        </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    Credit : Towsey 2017</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power, tn, fn, _ = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; EAS, ECU, ECV, EPS, EPS_KURT, EPS_SKEW = maad.features.spectral_entropy(Sxx_power, fn, flim=(2000,10000)) </span>
<span class="sd">    &gt;&gt;&gt; print(&#39;EAS: %2.2f / ECU: %2.2f / ECV: %2.2f / EPS: %2.2f / EPS_KURT: %2.2f / EPS_SKEW: %2.2f&#39; % (EAS, ECU, ECV, EPS, EPS_KURT, EPS_SKEW))</span>
<span class="sd">    EAS: 0.27 / ECU: 0.49 / ECV: 0.24 / EPS: 1.00 / EPS_KURT: 17.58 / EPS_SKEW: 3.55</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flim</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;WARNING: flim must be a tupple (fmin, fmax) or None&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="k">if</span> <span class="n">flim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span> <span class="n">flim</span><span class="o">=</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">fn</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    
    <span class="c1"># select the indices corresponding to the frequency range</span>
    <span class="n">iBAND</span> <span class="o">=</span> <span class="n">index_bw</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">flim</span><span class="p">)</span>
    
    <span class="c1"># force Sxx to be an ndarray</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Sxx</span><span class="p">)</span>

    <span class="c1"># TOWSEY &amp; BUXTON : only on the bio band</span>
    <span class="c1"># EAS [TOWSEY] #</span>
    <span class="c1">####  COMMENT : Result a bit different due to different Hilbert implementation</span>
    <span class="n">X_mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Hf</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X_mean</span><span class="p">)</span>
    <span class="n">EAS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Hf</span>

    <span class="c1">#### Entropy of spectral variance (along the time axis for each frequency)</span>
    <span class="sd">&quot;&quot;&quot; ECU [TOWSEY] &quot;&quot;&quot;</span>
    <span class="n">X_Var</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Hf_var</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X_Var</span><span class="p">)</span>
    <span class="n">ECU</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Hf_var</span>

    <span class="c1">#### Entropy of coefficient of variance (along the time axis for each frequency)</span>
    <span class="sd">&quot;&quot;&quot; ECV [TOWSEY] &quot;&quot;&quot;</span>
    <span class="n">X_CoV</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Hf_CoV</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">X_CoV</span><span class="p">)</span>
    <span class="n">ECV</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Hf_CoV</span>
    
    <span class="c1">#### Entropy of spectral maxima </span>
    <span class="sd">&quot;&quot;&quot; EPS [TOWSEY]  &quot;&quot;&quot;</span>
    <span class="n">ioffset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">iBAND</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Nbins</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">iBAND</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span>  
    <span class="n">imax_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">ioffset</span>
    <span class="n">imax_X</span> <span class="o">=</span> <span class="n">fn</span><span class="p">[</span><span class="n">imax_X</span><span class="p">]</span>
    <span class="n">max_X_bin</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">imax_X</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">Nbins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">flim</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">max_X_bin</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="n">max_X_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">max_X_bin</span><span class="p">))</span>
        <span class="n">EPS</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
        <span class="c1">#### Kurtosis of spectral maxima</span>
        <span class="n">EPS_KURT</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
        <span class="c1">#### skewness of spectral maxima</span>
        <span class="n">EPS_SKEW</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_X_bin</span> <span class="o">=</span> <span class="n">max_X_bin</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">max_X_bin</span><span class="p">)</span>
        <span class="n">Hf_fmax</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">max_X_bin</span><span class="p">)</span>
        <span class="n">EPS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Hf_fmax</span>    
        <span class="c1">#### Kurtosis of spectral maxima</span>
        <span class="n">EPS_KURT</span> <span class="o">=</span> <span class="n">kurtosis</span><span class="p">(</span><span class="n">max_X_bin</span><span class="p">)</span>
        <span class="c1">#### skewness of spectral maxima</span>
        <span class="n">EPS_SKEW</span> <span class="o">=</span> <span class="n">skewness</span><span class="p">(</span><span class="n">max_X_bin</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">display</span><span class="p">:</span> 
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">X_mean</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">X_mean</span><span class="p">),</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Normalized mean&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">X_Var</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">X_Var</span><span class="p">),</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Normalized variance&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">X_CoV</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">X_CoV</span><span class="p">),</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Normalized covariance&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fn</span><span class="p">[</span><span class="n">iBAND</span><span class="p">],</span> <span class="n">max_X_bin</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">max_X_bin</span><span class="p">),</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Normalized Spectral max&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Signals&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">EAS</span><span class="p">,</span> <span class="n">ECU</span><span class="p">,</span> <span class="n">ECV</span><span class="p">,</span> <span class="n">EPS</span><span class="p">,</span> <span class="n">EPS_KURT</span><span class="p">,</span> <span class="n">EPS_SKEW</span></div>

<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="spectral_cover"><a class="viewcode-back" href="../../../generated/maad.features.spectral_cover.html#maad.features.spectral_cover">[docs]</a><span class="k">def</span> <span class="nf">spectral_cover</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">flim_LF</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">),</span> <span class="n">flim_MF</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">10000</span><span class="p">),</span> 
                   <span class="n">flim_HF</span><span class="o">=</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span><span class="mi">20000</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the proportion (cover) of the spectrogram above a threshold for </span>
<span class="sd">    three bandwidths : low frequency band (LF), medium frequency band (MF) and </span>
<span class="sd">    high frequency band (HF).  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx : 2D array of floats</span>
<span class="sd">        Spectrogram 2D in dB. Usually, better to work with spectrogram without </span>
<span class="sd">        stationnary noise in order to measure only acoustic activity above the</span>
<span class="sd">        background noise</span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        frequency vector </span>
<span class="sd">    dB_threshold : scalar, optional, default is 3dB</span>
<span class="sd">        data &gt;Threshold is considered to be an activity </span>
<span class="sd">    flim_LF : tupple, optional, default is (0,1000)</span>
<span class="sd">        Low frequency band in Hz</span>
<span class="sd">    flim_MF : tupple, optional, default is (1000,10000)</span>
<span class="sd">        mid frequency band in Hz    </span>
<span class="sd">    flim_HF : tupple, optional, default is (10000,20000)</span>
<span class="sd">        high frequency band in Hz</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    LFC :scalar</span>
<span class="sd">        Proportion of the LF bandwidth of the spectrogram with activity above </span>
<span class="sd">        the threshold</span>
<span class="sd">    MFC: scalar</span>
<span class="sd">        Proportion of the MF bandwidth of the spectrogram with activity above </span>
<span class="sd">        the threshold</span>
<span class="sd">    HFC: scalar</span>
<span class="sd">        Proportion of the HF bandwidth of the spectrogram with activity above </span>
<span class="sd">        the threshold</span>
<span class="sd">        </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Towsey, Michael (2013), Noise Removal from Waveforms and Spectrograms Derived </span>
<span class="sd">    from Natural Recordings of the Environment. Queensland University of Technology, Brisbane.</span>
<span class="sd">    </span>
<span class="sd">    Examples :</span>
<span class="sd">    ----------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power, tn, fn, ext = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; Sxx_noNoise= maad.sound.median_equalizer(Sxx_power, display=True, extent=ext) </span>
<span class="sd">    &gt;&gt;&gt; Sxx_dB_noNoise = maad.util.power2dB(Sxx_noNoise)</span>
<span class="sd">    &gt;&gt;&gt; LFC, MFC, HFC = maad.features.spectral_cover(Sxx_dB_noNoise, fn) </span>
<span class="sd">    &gt;&gt;&gt; print(&#39;LFC: %2.2f / MFC: %2.2f / HFC: %2.2f&#39; % (LFC, MFC, HFC))</span>
<span class="sd">    LFC: 0.15 / MFC: 0.19 / HFC: 0.13</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="c1">### For Sxx to be a ndarray</span>
    <span class="n">Sxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Sxx</span><span class="p">)</span> 
    
    <span class="n">idx</span> <span class="o">=</span> <span class="n">index_bw</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">flim_LF</span><span class="p">)</span>
    <span class="n">lowFreqCover</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_acoustic_activity</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">LFC</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">lowFreqCover</span><span class="p">)</span>
    
    <span class="n">idx</span> <span class="o">=</span> <span class="n">index_bw</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">flim_MF</span><span class="p">)</span>
    <span class="n">midFreqCover</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_acoustic_activity</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">MFC</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">midFreqCover</span><span class="p">)</span>
    
    <span class="n">idx</span> <span class="o">=</span> <span class="n">index_bw</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">flim_HF</span><span class="p">)</span>
    <span class="n">highFreqCover</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_acoustic_activity</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">HFC</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">highFreqCover</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">LFC</span><span class="p">,</span> <span class="n">MFC</span><span class="p">,</span> <span class="n">HFC</span></div>


<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="spectral_activity"><a class="viewcode-back" href="../../../generated/maad.features.spectral_activity.html#maad.features.spectral_activity">[docs]</a><span class="k">def</span> <span class="nf">spectral_activity</span> <span class="p">(</span><span class="n">Sxx_dB</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the acoustic activity on a spectrogram.</span>
<span class="sd">    </span>
<span class="sd">    Acoustic activity corresponds to the portion of the spectrogram above a </span>
<span class="sd">    threshold frequency per frequency along time axis [1]_</span>
<span class="sd">    The function computes for each frequency bin:</span>
<span class="sd">        - ACTfract : proportion (fraction) of points above the threshold </span>
<span class="sd">        - ACTcount : number of points above the threshold</span>
<span class="sd">        - ACTmean : mean value (in dB) of the portion of the signal above the threhold</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx_dB : 2D array of floats</span>
<span class="sd">        Spectrogram 2D in dB. Usually, better to work with spectrogram without </span>
<span class="sd">        stationnary noise in order to measure only acoustic activity above the</span>
<span class="sd">        background noise</span>
<span class="sd">    dB_threshold : scalar, optional, default is 6dB</span>
<span class="sd">        data &gt;Threshold is considered to be an activity </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    ACTspfract :ndarray of scalars</span>
<span class="sd">        proportion (fraction) of points above the threshold for each frequency bin</span>
<span class="sd">    ACTspcount: ndarray of scalars</span>
<span class="sd">        number of points above the threshold for each frequency bin</span>
<span class="sd">    ACTspmean: scalar</span>
<span class="sd">        mean value (in dB) of the portion of the signal above the threhold</span>
<span class="sd">        </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    Towsey, Michael (2013), Noise Removal from Waveforms and Spectrograms Derived </span>
<span class="sd">    from Natural Recordings of the Environment. Queensland University of Technology, Brisbane.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power, tn, fn, ext = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; Sxx_noNoise= maad.sound.median_equalizer(Sxx_power, display=True, extent=ext) </span>
<span class="sd">    &gt;&gt;&gt; Sxx_dB_noNoise = maad.util.power2dB(Sxx_noNoise)</span>
<span class="sd">    &gt;&gt;&gt; ACTspfract_per_bin, ACTspcount_per_bin, ACTspmean_per_bin = maad.features.spectral_activity(Sxx_dB_noNoise)  </span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Mean proportion of spectrogram above threshold : %2.2f%%&#39; %np.mean(ACTspfract_per_bin))</span>
<span class="sd">    Mean proportion of spectrogram above threshold : 0.07%</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="c1">### For Sxx_dB to be a ndarray</span>
    <span class="n">Sxx_dB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Sxx_dB</span><span class="p">)</span> 
    
    <span class="n">ACTspfract</span><span class="p">,</span> <span class="n">ACTspcount</span><span class="p">,</span> <span class="n">ACTspmean</span> <span class="o">=</span> <span class="n">_acoustic_activity</span> <span class="p">(</span><span class="n">Sxx_dB</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="p">,</span> 
                                                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ACTspfract</span><span class="p">,</span> <span class="n">ACTspcount</span><span class="p">,</span> <span class="n">ACTspmean</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="spectral_events"><a class="viewcode-back" href="../../../generated/maad.features.spectral_events.html#maad.features.spectral_events">[docs]</a><span class="k">def</span> <span class="nf">spectral_events</span> <span class="p">(</span><span class="n">Sxx_dB</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">rejectDuration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute acoustic events from a spectrogram [1]_.</span>
<span class="sd">    </span>
<span class="sd">    An acoustic event corresponds to the period of the signal above a </span>
<span class="sd">    threshold. An acoustic event could be short (at list one point if </span>
<span class="sd">    rejectDuration is None) or very long (the duration of the entire audio). </span>
<span class="sd">    Two acoustic events are separated by a period with low audio signal (ie</span>
<span class="sd">    below the threshold). Acoustic events are calculated frequency by frequency</span>
<span class="sd">    along time axis</span>
<span class="sd">    This function computes:</span>
<span class="sd">        - EVNspFraction : Fraction of events duration over total duration</span>
<span class="sd">        - EVNspmean : mean events duration (s)</span>
<span class="sd">        - EVNspcount : number of events per s</span>
<span class="sd">        - EVNsp : binary vector or matrix with 1 corresponding to event position</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx_dB : 2D array of floats</span>
<span class="sd">        2D in dB. Usually, better to work with spectrogram without </span>
<span class="sd">        stationnary noise in order to measure only acoustic activity above the</span>
<span class="sd">        background noise</span>
<span class="sd">    dt : float</span>
<span class="sd">        time resolution in s (ie tn[1]-tn[0])</span>
<span class="sd">    dB_threshold : scalar, optional, default is 6dB</span>
<span class="sd">        data &gt;Threshold is considered to be an event </span>
<span class="sd">        if the length is &gt; rejectLength</span>
<span class="sd">    rejectDuration : scalar, optional, default is None</span>
<span class="sd">        event shorter than rejectDuration are discarded</span>
<span class="sd">        duration is in s</span>
<span class="sd">    display : boolean, optional, default is false</span>
<span class="sd">        Display a plot with the number of events per s (EVNspCount) and</span>
<span class="sd">        a binary image with the detected events.</span>
<span class="sd">    \*\*kwargs : optional. See matplotlib documentation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    EVNspFract :scalar</span>
<span class="sd">        Fraction: events duration over total duration</span>
<span class="sd">    EVNspMean: scalar</span>
<span class="sd">        mean events duration in s</span>
<span class="sd">    EVNspCount: scalar</span>
<span class="sd">        number of events per s</span>
<span class="sd">    EVNsp: ndarray of floats </span>
<span class="sd">        binary matrix.</span>
<span class="sd">        1 corresponds to event</span>
<span class="sd">        0 corresponds to background</span>

<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Towsey, Michael (2013), Noise Removal from Waveforms and Spectrograms Derived </span>
<span class="sd">    from Natural Recordings of the Environment. Queensland University of Technology, Brisbane.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power, tn, fn, ext = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; Sxx_noNoise= maad.sound.median_equalizer(Sxx_power) </span>
<span class="sd">    &gt;&gt;&gt; Sxx_dB_noNoise = maad.util.power2dB(Sxx_noNoise)</span>
<span class="sd">    &gt;&gt;&gt; EVNspFract_per_bin, EVNspMean_per_bin, EVNspCount_per_bin, EVNsp = maad.features.spectral_events(Sxx_dB_noNoise, dt=tn[1]-tn[0], dB_threshold=6, rejectDuration=0.1, display=True, extent=ext)  </span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Mean proportion of spectrogram with event s: %2.2f%%&#39; %np.mean(EVNspFract_per_bin))</span>
<span class="sd">    Mean proportion of spectrogram with events : 0.01%</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="c1">### For wave to be a ndarray</span>
    <span class="n">Sxx_dB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Sxx_dB</span><span class="p">)</span> 
        
    <span class="n">EVNspSum</span><span class="p">,</span> <span class="n">EVNspMean</span><span class="p">,</span> <span class="n">EVNspCount</span><span class="p">,</span> <span class="n">EVNsp</span> <span class="o">=</span> <span class="n">_acoustic_events</span> <span class="p">(</span><span class="n">Sxx_dB</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> 
                                                               <span class="n">dB_threshold</span><span class="p">,</span> 
                                                               <span class="n">rejectDuration</span><span class="o">=</span><span class="n">rejectDuration</span><span class="p">)</span>
    
    <span class="c1"># EVNspFract = EVNspSum  * total_duration</span>
    <span class="n">EVNspFract</span> <span class="o">=</span> <span class="n">EVNspSum</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">Sxx_dB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">display</span> <span class="p">:</span>
        <span class="c1"># display Number of events/s / frequency</span>
        <span class="n">extent</span> <span class="o">=</span>  <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;extent&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span> 
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Sxx_dB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">Sxx_dB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;frequency [Hz]&#39;</span> 
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Sxx_dB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;pseudofrequency [points]&#39;</span>   

        <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">EVNspCount</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;EVNspCount : Number of events/s&#39;</span><span class="p">)</span>
        
    <span class="c1"># display EVENTS detected in the spectrogram</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;Time [sec]&#39;</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;frequency [Hz]&#39;</span> 
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Sxx_dB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">Sxx_dB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;pseudoTime [sec]&#39;</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;pseudofrequency [points]&#39;</span>   
    
        <span class="c1"># set the paramters of the figure</span>
        <span class="n">title</span>  <span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span><span class="s1">&#39;Events detected&#39;</span><span class="p">)</span> 
        <span class="n">cmap</span>   <span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>  
        <span class="n">figsize</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;figsize&#39;</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span>  
        <span class="n">vmin</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  
        <span class="n">vmax</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="p">,</span> <span class="n">fig</span> <span class="o">=</span> <span class="n">plot2d</span> <span class="p">(</span><span class="n">EVNsp</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">now</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> 
                          <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="n">ylabel</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="n">xlabel</span><span class="p">,</span>
                          <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>  <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> 
    
    <span class="k">return</span> <span class="n">EVNspFract</span><span class="p">,</span> <span class="n">EVNspMean</span><span class="p">,</span> <span class="n">EVNspCount</span><span class="p">,</span> <span class="n">EVNsp</span></div>


<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="acoustic_complexity_index"><a class="viewcode-back" href="../../../generated/maad.features.acoustic_complexity_index.html#maad.features.acoustic_complexity_index">[docs]</a><span class="k">def</span> <span class="nf">acoustic_complexity_index</span><span class="p">(</span><span class="n">Sxx</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Acoustic Complexity Index (ACI) from a spectrogram [1]_.</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx : ndarray of floats</span>
<span class="sd">        2d : Spectrogram (i.e matrix of spectrum)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    ACI_xx: 2d ndarray of scalars</span>
<span class="sd">        Acoustic Complexity Index of the spectrogram</span>
<span class="sd">    </span>
<span class="sd">    ACI_per_bin: 1d ndarray of scalars</span>
<span class="sd">        ACI value for each frequency bin</span>
<span class="sd">        sum(ACI_xx,axis=1)</span>
<span class="sd">        </span>
<span class="sd">    ACI_sum: scalar</span>
<span class="sd">        Sum of ACI value per frequency bin (Common definition)</span>
<span class="sd">        sum(ACI_per_bin)</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----   </span>
<span class="sd">    ACI depends on the duration of the spectrogram as the derivation of the signal</span>
<span class="sd">    is normalized by the sum of the signal. </span>
<span class="sd">    Thus, if the background noise is high due to high acoustic activity the</span>
<span class="sd">    normalization by the sum of the signal reduced ACI.</span>
<span class="sd">    So ACI is low when there is no acoustic activity or high acoustic activity </span>
<span class="sd">    with continuous background noise.</span>
<span class="sd">    ACI is high only when acoustic activity is medium, with sounds well above</span>
<span class="sd">    the background noise.</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Pieretti N, Farina A, Morri FD (2011) A new methodology to infer the singing </span>
<span class="sd">    activity of an avian community: the Acoustic Complexity Index (ACI). </span>
<span class="sd">    Ecological Indicators, 11, 868-873.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx, tn, fn, ext = maad.sound.spectrogram (s, fs, mode=&#39;amplitude&#39;)  </span>
<span class="sd">    &gt;&gt;&gt; _, _ , ACI  = maad.features.acoustic_complexity_index(Sxx)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;ACI : %2.0f &#39; %ACI)</span>
<span class="sd">    ACI : 306</span>

<span class="sd">    &quot;&quot;&quot;</span>   
    <span class="n">ACI_xx</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>       
    <span class="n">ACI_per_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ACI_xx</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ACI_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ACI_per_bin</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ACI_xx</span><span class="p">,</span> <span class="n">ACI_per_bin</span><span class="p">,</span> <span class="n">ACI_sum</span> </div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="acoustic_diversity_index"><a class="viewcode-back" href="../../../generated/maad.features.acoustic_diversity_index.html#maad.features.acoustic_diversity_index">[docs]</a><span class="k">def</span> <span class="nf">acoustic_diversity_index</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> 
                            <span class="n">dB_threshold</span><span class="o">=-</span><span class="mi">50</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s2">&quot;shannon&quot;</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Acoustic Diversity Index (ADI) from a spectrogram [1]_.</span>
<span class="sd">    </span>
<span class="sd">    The diversity can be computed using Shannon, Simpson, or the inverse Simpson diversity index.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx : ndarray of floats</span>
<span class="sd">        2d : Spectrogram</span>
<span class="sd">    </span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        frequency vector</span>
<span class="sd">    </span>
<span class="sd">    fmin : scalar, optional, default is 0</span>
<span class="sd">        Minimum frequency in Hz</span>
<span class="sd">        </span>
<span class="sd">    fmax : scalar, optional, default is 20000</span>
<span class="sd">        Maximum frequency in Hz</span>
<span class="sd">        </span>
<span class="sd">    bin_step : scalar, optional, default is 500</span>
<span class="sd">        Frequency step in Hz</span>
<span class="sd">    </span>
<span class="sd">    dB_threshold : scalar, optional, default is -50dB</span>
<span class="sd">        Threshold to compute the score (ie. the number of data &gt; threshold,</span>
<span class="sd">        normalized by the length)</span>
<span class="sd">        </span>
<span class="sd">    index : string, optional, default is &quot;shannon&quot;</span>
<span class="sd">        - &quot;shannon&quot; : Shannon entropy is calculated on the vector of scores</span>
<span class="sd">        - &quot;simpson&quot; : Simpson index is calculated on the vector of scores</span>
<span class="sd">        - &quot;invsimpson&quot; : Inverse Simpson index is calculated on the vector of scores</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    ADI : scalar </span>
<span class="sd">        Acoustic Diversity Index of the spectrogram (ie. index of the vector </span>
<span class="sd">        of scores)</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Acoustic Eveness Index (AEI) and the Acoustic Diversity Index (ADI) are negatively correlated.</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    acoustic_eveness_index</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Villanueva-Rivera, L. J., B. C. Pijanowski, J. Doucette, and B. Pekin. 2011. </span>
<span class="sd">    A primer of acoustic analysis for landscape ecologists. Landscape Ecology 26: 1233-1246.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx, tn, fn, ext = maad.sound.spectrogram (s, fs, mode=&#39;amplitude&#39;)  </span>
<span class="sd">    &gt;&gt;&gt; ADI  = maad.features.acoustic_diversity_index(Sxx,fn)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;ADI : %2.2f &#39; %ADI)</span>
<span class="sd">    ADI : 2.45 </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="c1"># number of frequency intervals to compute the score</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">fmax</span><span class="o">-</span><span class="n">fmin</span><span class="p">)</span><span class="o">/</span><span class="n">bin_step</span><span class="p">)</span>
    
    <span class="c1"># convert into dB and normalization by the max</span>
    <span class="n">Sxx_dB</span> <span class="o">=</span> <span class="n">amplitude2dB</span><span class="p">(</span><span class="n">Sxx</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">Sxx</span><span class="p">))</span>       
    
    <span class="c1"># Score for each frequency in the frequency bandwith</span>
    <span class="n">s_sum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fmin</span><span class="o">+</span><span class="n">bin_step</span><span class="o">*</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f0</span><span class="o">+</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">s</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_score</span><span class="p">(</span><span class="n">Sxx_dB</span><span class="p">[</span><span class="n">index_bw</span><span class="p">(</span><span class="n">fn</span><span class="p">,(</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">)),:],</span> <span class="n">threshold</span><span class="o">=</span><span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">s_sum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s_sum</span><span class="p">)</span>
    
    <span class="c1"># Entropy</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">==</span><span class="s2">&quot;shannon&quot;</span><span class="p">:</span>
        <span class="n">ADI</span> <span class="o">=</span> <span class="n">_shannonEntropy</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="s2">&quot;simpson&quot;</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">ADI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="s2">&quot;invsimpson&quot;</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">ADI</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>   
    
    <span class="k">return</span> <span class="n">ADI</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="acoustic_eveness_index"><a class="viewcode-back" href="../../../generated/maad.features.acoustic_eveness_index.html#maad.features.acoustic_eveness_index">[docs]</a><span class="k">def</span> <span class="nf">acoustic_eveness_index</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> 
                          <span class="n">dB_threshold</span><span class="o">=-</span><span class="mi">50</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Acoustic Eveness Index (AEI) from a spectrogram [1]_.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx: ndarray of floats</span>
<span class="sd">        2d : Spectrogram</span>
<span class="sd">    </span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        frequency vector</span>
<span class="sd">    </span>
<span class="sd">    fmin : scalar, optional, default is 0</span>
<span class="sd">        Minimum frequency in Hz</span>
<span class="sd">        </span>
<span class="sd">    fmax : scalar, optional, default is 20000</span>
<span class="sd">        Maximum frequency in Hz</span>
<span class="sd">        </span>
<span class="sd">    bin_step : scalar, optional, default is 500</span>
<span class="sd">        Frequency step in Hz</span>
<span class="sd">    </span>
<span class="sd">    dB_threshold : scalar, optional, default is -50</span>
<span class="sd">        Threshold to compute the score (ie. the number of data &gt; threshold,</span>
<span class="sd">        normalized by the length)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    AEI : scalar </span>
<span class="sd">        Acoustic Eveness of the spectrogram (ie. Gini of the vector of scores)</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Acoustic Eveness Index (AEI) and the Acoustic Diversity Index (ADI) are negatively correlated.</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    acoustic_diversity_index</span>
<span class="sd">        </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Villanueva-Rivera, L. J., B. C. Pijanowski, J. Doucette, and B. Pekin. 2011. </span>
<span class="sd">    A primer of acoustic analysis for landscape ecologists. Landscape Ecology 26: 1233-1246.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx, tn, fn, ext = maad.sound.spectrogram (s, fs, mode=&#39;amplitude&#39;)  </span>
<span class="sd">    &gt;&gt;&gt; AEI  = maad.features.acoustic_eveness_index(Sxx,fn)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;AEI : %2.2f &#39; %AEI)</span>
<span class="sd">    AEI : 0.56    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># number of frequency intervals to compute the score</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">fmax</span><span class="o">-</span><span class="n">fmin</span><span class="p">)</span><span class="o">/</span><span class="n">bin_step</span><span class="p">)</span>
    
    <span class="c1"># convert into dB and normalization by the max</span>
    <span class="n">Sxx_dB</span> <span class="o">=</span> <span class="n">amplitude2dB</span><span class="p">(</span><span class="n">Sxx</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">Sxx</span><span class="p">))</span>
 
    <span class="c1"># Score for each frequency in the frequency bandwith</span>
    <span class="n">s_sum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fmin</span><span class="o">+</span><span class="n">bin_step</span><span class="o">*</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f0</span><span class="o">+</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">s</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_score</span><span class="p">(</span><span class="n">Sxx_dB</span><span class="p">[</span><span class="n">index_bw</span><span class="p">(</span><span class="n">fn</span><span class="p">,(</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">)),:],</span> <span class="n">threshold</span><span class="o">=</span><span class="n">dB_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">s_sum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s_sum</span><span class="p">)</span>
    
    <span class="c1"># Gini</span>
    <span class="n">AEI</span> <span class="o">=</span> <span class="n">_gini</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">AEI</span></div>

<span class="c1">#=============================================================================</span>
<span class="c1">####    Indices based on the energy</span>
<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="soundscape_index"><a class="viewcode-back" href="../../../generated/maad.features.soundscape_index.html#maad.features.soundscape_index">[docs]</a><span class="k">def</span> <span class="nf">soundscape_index</span> <span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span><span class="n">fn</span><span class="p">,</span><span class="n">flim_bioPh</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">10000</span><span class="p">),</span><span class="n">flim_antroPh</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">),</span> 
                     <span class="n">R_compatible</span> <span class="o">=</span> <span class="s1">&#39;soundecology&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Normalized Difference Soundscape Index from a power spectrogram [1]_.</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx_power : ndarray of floats</span>
<span class="sd">        2d : Power Spectrogram</span>
<span class="sd">    </span>
<span class="sd">    fn : vector</span>
<span class="sd">        frequency vector </span>
<span class="sd">        </span>
<span class="sd">    flim_bioPh : tupple (fmin, fmax), optional, default is (1000,10000)</span>
<span class="sd">        Frequency band of the biophony</span>
<span class="sd">    </span>
<span class="sd">    flim_antroPh: tupple (fmin, fmax), optional, default is (0,1000)</span>
<span class="sd">        Frequency band of the anthropophony</span>
<span class="sd">    </span>
<span class="sd">    R_compatible : string, optional, default is &quot;soundecology&quot;</span>
<span class="sd">        if &#39;soundecology&#39;, the result is similar to the package SoundEcology in R </span>
<span class="sd">        Otherwise, the result is specific to maad or Seewave R package</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDSI : scalar</span>
<span class="sd">        (bioPh-antroPh)/(bioPh+antroPh)</span>
<span class="sd">    ratioBA : scalar</span>
<span class="sd">        biophonic energy / anthropophonic energy</span>
<span class="sd">    antroPh : scalar</span>
<span class="sd">        Acoustic energy in the anthropophonic bandwidth</span>
<span class="sd">    bioPh : scalar</span>
<span class="sd">        Acoustic energy in the biophonic bandwidth</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Kasten, Eric P., Stuart H. Gage, Jordan Fox, and Wooyeong Joo. 2012. </span>
<span class="sd">    The Remote Environmental Assessment Laboratory&#39;s Acoustic Library: An Archive </span>
<span class="sd">    for Studying Soundscape Ecology. Ecological Informatics 12: 50-67.</span>
<span class="sd">    </span>
<span class="sd">    Inspired by Seewave and soundecology R packages.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power, tn, fn, ext = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; NDSI, ratioBA, antroPh, bioPh  = maad.features.soundscape_index(Sxx_power,fn)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;NDSI Soundecology : %2.2f &#39; %NDSI)</span>
<span class="sd">    NDSI Soundecology : 0.10</span>
<span class="sd">    &gt;&gt;&gt; NDSI, ratioBA, antroPh, bioPh  = maad.features.soundscape_index(Sxx_power,fn,R_compatible=None)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;NDSI MAAD: %2.2f &#39; %NDSI)</span>
<span class="sd">    NDSI MAAD : 0.99</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">R_compatible</span> <span class="o">==</span> <span class="s1">&#39;soundecology&#39;</span> <span class="p">:</span>
        <span class="c1"># Step is determined as the difference between anthro_max and anthro_min</span>
        <span class="n">bin_step</span> <span class="o">=</span> <span class="n">flim_antroPh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">flim_antroPh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#Convert into bins</span>
        <span class="n">Sxx_bins</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">into_bins</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">bin_min</span><span class="o">=</span><span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_max</span><span class="o">=</span><span class="n">fn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                  <span class="n">bin_step</span><span class="o">=</span><span class="n">bin_step</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Frequency resolution is 1000 Hz</span>
        <span class="n">bin_step</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="c1">#Convert into bins</span>
        <span class="n">Sxx_bins</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">into_bins</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">bin_min</span><span class="o">=</span><span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_max</span><span class="o">=</span><span class="n">fn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                  <span class="n">bin_step</span><span class="o">=</span><span class="n">bin_step</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
        <span class="c1"># In Seewave, the first bin (0kHz) is removed</span>
        <span class="n">Sxx_bins</span> <span class="o">=</span> <span class="n">Sxx_bins</span><span class="p">[</span><span class="n">bins</span><span class="o">&gt;=</span><span class="mi">1000</span><span class="p">,]</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">bins</span><span class="o">&gt;=</span><span class="mi">1000</span><span class="p">]</span>
        
    <span class="c1"># Energy in BIOBAND</span>
    <span class="n">bioPh</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Sxx_bins</span><span class="p">[</span><span class="n">index_bw</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">flim_bioPh</span><span class="p">),</span> <span class="p">])</span>
    <span class="c1"># Energy in ANTHROPOBAND</span>
    <span class="n">antroPh</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Sxx_bins</span><span class="p">[</span><span class="n">index_bw</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">flim_antroPh</span><span class="p">),</span> <span class="p">])</span>
    
    <span class="c1"># NDSI and ratioBA indices </span>
    <span class="n">NDSI</span> <span class="o">=</span> <span class="p">(</span><span class="n">bioPh</span><span class="o">-</span><span class="n">antroPh</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">bioPh</span><span class="o">+</span><span class="n">antroPh</span><span class="p">)</span>
    <span class="n">ratioBA</span> <span class="o">=</span> <span class="n">bioPh</span> <span class="o">/</span> <span class="n">antroPh</span>

    <span class="k">return</span> <span class="n">NDSI</span><span class="p">,</span> <span class="n">ratioBA</span><span class="p">,</span> <span class="n">antroPh</span><span class="p">,</span> <span class="n">bioPh</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="bioacoustics_index"><a class="viewcode-back" href="../../../generated/maad.features.bioacoustics_index.html#maad.features.bioacoustics_index">[docs]</a><span class="k">def</span> <span class="nf">bioacoustics_index</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">flim</span><span class="o">=</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">15000</span><span class="p">),</span> <span class="n">R_compatible</span> <span class="o">=</span><span class="s1">&#39;soundecology&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Bioacoustics Index from a spectrogram [1]_.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx : ndarray of floats</span>
<span class="sd">        matrix : Spectrogram  </span>
<span class="sd">    fn : vector</span>
<span class="sd">        frequency vector </span>
<span class="sd">    flim : tupple (fmin, fmax), optional, default is (2000, 15000)</span>
<span class="sd">        Frequency band used to compute the bioacoustic index.</span>
<span class="sd">    R_compatible : string, default is &quot;soundecology&quot;</span>
<span class="sd">        if &#39;soundecology&#39;, the result is similar to the package SoundEcology in R </span>
<span class="sd">        Otherwise, the result is specific to maad</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    BI : scalar</span>
<span class="sd">        Bioacoustics Index</span>
<span class="sd">    </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Boelman NT, Asner GP, Hart PJ, Martin RE. 2007. Multi-trophic </span>
<span class="sd">    invasion resistance in Hawaii: bioacoustics, field surveys, and airborne </span>
<span class="sd">    remote sensing. Ecological Applications 17: 2137-2144.</span>
<span class="sd">    </span>
<span class="sd">    Ported and modified from the soundecology R package.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----    </span>
<span class="sd">    Soundecology compatible version:</span>
<span class="sd">        - average of dB value</span>
<span class="sd">        - remove negative value in order to get positive values only</span>
<span class="sd">        - dividing by the frequency resolution df instead of multiplication</span>
<span class="sd">    </span>
<span class="sd">    Examples :</span>
<span class="sd">    ----------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx, tn, fn, ext = maad.sound.spectrogram (s, fs,mode=&#39;amplitude&#39;)  </span>
<span class="sd">    &gt;&gt;&gt; BI = maad.features.bioacoustics_index(Sxx,fn)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;BI Soundecology : %2.2f &#39; %BI)</span>
<span class="sd">    BI Soundecology : 52.84</span>
<span class="sd">    &gt;&gt;&gt; BI  = maad.features.bioacoustics_index(Sxx,fn,R_compatible=None)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;BI MAAD: %2.2f &#39; %BI)</span>
<span class="sd">    BI MAAD : 17.05</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="c1"># select the indices corresponding to the frequency bins range</span>
    <span class="n">indf</span> <span class="o">=</span> <span class="n">index_bw</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">flim</span><span class="p">)</span>
    
    <span class="c1"># frequency resolution. </span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">fn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># ======= As soundecology</span>
    <span class="k">if</span> <span class="n">R_compatible</span> <span class="o">==</span> <span class="s1">&#39;soundecology&#39;</span> <span class="p">:</span>
        <span class="c1"># Mean Sxx normalized by the max</span>
        <span class="n">meanSxx</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">Sxx</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">Sxx</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Convert into dB</span>
        <span class="n">meanSxxdB</span> <span class="o">=</span> <span class="n">amplitude2dB</span><span class="p">(</span><span class="n">meanSxx</span><span class="p">)</span>
        
        <span class="c1"># &quot;normalization&quot; in order to get positive &#39;vectical&#39; values </span>
        <span class="n">meanSxxdB</span> <span class="o">=</span> <span class="n">meanSxxdB</span><span class="p">[</span><span class="n">indf</span><span class="p">,]</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">meanSxxdB</span><span class="p">[</span><span class="n">indf</span><span class="p">,])</span>
    
        <span class="c1"># this is not the area under the curve...</span>
        <span class="c1"># what is the meaning of an area under the curve in dB...</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">meanSxxdB</span><span class="p">)</span><span class="o">/</span><span class="n">df</span>
    <span class="c1"># ======= maad version    </span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># better to average the PSD for energy conservation</span>
        <span class="n">PSDxx_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sxx</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">Sxx</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">meanPSDxx_norm</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">PSDxx_norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compute the area</span>
        <span class="c1"># take the sqrt in order to go back to Sxx</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">meanPSDxx_norm</span><span class="p">))</span><span class="o">*</span> <span class="n">df</span> 
        
    <span class="k">return</span> <span class="n">BI</span></div>
        
<span class="c1">#=============================================================================</span>
<span class="c1">#       </span>
<span class="c1">#   New ecoacoustics indices introduced by S. HAUPERT, 2020</span>
<span class="c1">#   </span>
<span class="c1">#============================================================================= </span>

<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="temporal_leq"><a class="viewcode-back" href="../../../generated/maad.features.temporal_leq.html#maad.features.temporal_leq">[docs]</a><span class="k">def</span> <span class="nf">temporal_leq</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">Vadc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sensitivity</span><span class="o">=-</span><span class="mi">35</span><span class="p">,</span> <span class="n">dBref</span><span class="o">=</span><span class="mi">94</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Equivalent Continuous Sound level (Leq) of an audio signal </span>
<span class="sd">    in the time domain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : 1D array of floats</span>
<span class="sd">        audio to process (wav)</span>
<span class="sd">    fs : Integer</span>
<span class="sd">        sampling frequency in Hz</span>
<span class="sd">    gain : integer</span>
<span class="sd">        Total gain applied to the sound (preamplifer + amplifier)</span>
<span class="sd">    Vadc : scalar, optional, default is 2Vpp (=&gt;+/-1V)</span>
<span class="sd">        Maximal voltage (peak to peak) converted by the analog to digital convertor ADC    </span>
<span class="sd">    sensitivity : float, optional, default is -35 (dB/V)</span>
<span class="sd">        Sensitivity of the microphone</span>
<span class="sd">    dBref : integer, optional, default is 94 (dBSPL)</span>
<span class="sd">        Pressure sound level used for the calibration of the microphone </span>
<span class="sd">        (usually 94dB, sometimes 114dB)</span>
<span class="sd">    dt : float, optional, default is 1 (second)</span>
<span class="sd">        Integration step to compute the Leq (Equivalent Continuous Sound level)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    LEQt: float</span>
<span class="sd">        Equivalent Continuous Sound level (Leq) in dB SPL</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Leq = maad.features.temporal_leq (s, fs, gain=42)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Leq is %2.1fdB SPL&#39; % Leq)</span>
<span class="sd">    Leq is 63.7dB SPL</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the Leq for each dt step</span>
    <span class="n">leq</span> <span class="o">=</span> <span class="n">wav2leq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">Vadc</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">sensitivity</span><span class="p">,</span> <span class="n">dBref</span><span class="p">)</span>
    <span class="c1"># average them</span>
    <span class="n">LEQt</span> <span class="o">=</span> <span class="n">mean_dB</span><span class="p">(</span><span class="n">leq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">LEQt</span></div>

<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="spectral_leq"><a class="viewcode-back" href="../../../generated/maad.features.spectral_LEQ.html#maad.features.spectral_leq">[docs]</a><span class="k">def</span> <span class="nf">spectral_leq</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">Vadc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sensitivity</span><span class="o">=-</span><span class="mi">35</span><span class="p">,</span> <span class="n">dBref</span><span class="o">=</span><span class="mi">94</span><span class="p">,</span> <span class="n">pRef</span> <span class="o">=</span> <span class="mf">20e-6</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Equivalent Continuous Sound level (Leq) from a power spectrum </span>
<span class="sd">    (1d) or power spectrogram (2d).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : ndarray of floats</span>
<span class="sd">        Spectrum (1d) or Spectrogram (2d). </span>
<span class="sd">        Work with PSD to be consistent with energy concervation</span>
<span class="sd">    gain : integer</span>
<span class="sd">        Total gain applied to the sound (preamplifer + amplifier)</span>
<span class="sd">    Vadc : scalar, optional, default is 2Vpp (=&gt;+/-1V)</span>
<span class="sd">        Maximal voltage (peak to peak) converted by the analog to digital convertor ADC    </span>
<span class="sd">    sensitivity : float, optional, default is -35 (dB/V)</span>
<span class="sd">        Sensitivity of the microphone</span>
<span class="sd">    dBref : integer, optional, default is 94 (dBSPL)</span>
<span class="sd">        Pressure sound level used for the calibration of the microphone </span>
<span class="sd">        (usually 94dB, sometimes 114dB)</span>
<span class="sd">    pRef : Sound pressure reference in the medium (air : 20e-6, water : 1e-6)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    LEQf: float</span>
<span class="sd">        Equivalent Continuous Sound level (Leq) in dB SPL</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,_,_,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; Leqf, Leqf_per_bin = maad.features.spectral_leq(Sxx_power, gain=42)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Leq (from spectrogram) is %2.1fdB SPL&#39; % Leqf)</span>
<span class="sd">    Leq (from spectrogram) is 63.7dB SPL</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># force X to be an ndarray</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="c1"># test if X has 2d (Spectrogram Pxx)</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span> 
        <span class="c1"># average spectrogram along time direction</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># convert power spectrogram/spectrum into dBSPL</span>
        <span class="n">LEQf_per_bin</span> <span class="o">=</span> <span class="n">power2dBSPL</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">Vadc</span><span class="p">,</span> <span class="n">sensitivity</span><span class="p">,</span> <span class="n">dBref</span><span class="p">,</span> <span class="n">pRef</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">LEQf_per_bin</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="c1"># convert spectrogram/spectrum into pressure</span>
    <span class="n">LEQf</span> <span class="o">=</span> <span class="n">psd2leq</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">Vadc</span><span class="p">,</span> <span class="n">sensitivity</span><span class="p">,</span> <span class="n">dBref</span><span class="p">,</span> <span class="n">pRef</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">LEQf</span><span class="p">,</span> <span class="n">LEQf_per_bin</span></div>

<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="more_entropy"><a class="viewcode-back" href="../../../generated/maad.features.more_entropy.html#maad.features.more_entropy">[docs]</a><span class="k">def</span> <span class="nf">more_entropy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the entropy of an audio signal using multiple methods.</span>
<span class="sd">    </span>
<span class="sd">    There are currently five types supported:</span>
<span class="sd">        - Havrda</span>
<span class="sd">        - Renyi</span>
<span class="sd">        - paired Shannon</span>
<span class="sd">        - gamma</span>
<span class="sd">        - Gini Simpson</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray of floats </span>
<span class="sd">        vector (1d) or matrix (2d) of scalars.</span>
<span class="sd">        Vector could be audio recording or spectrum</span>
<span class="sd">        Matrix could be spectrogram</span>
<span class="sd">    order : integer, default is 3</span>
<span class="sd">        determine the order of the entropy in case of Havrda, Renyi and gamma </span>
<span class="sd">        entropy. if order =2, Havrda is equal to Gini Simpson entropy</span>
<span class="sd">    axis : integer, default is 0</span>
<span class="sd">        In case of x is a matrix, select the row (axis=0) or the columns (axis=1)</span>
<span class="sd">        of the matrix to compute the entropies.  </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    H_Havrda : scalar</span>
<span class="sd">        Havrda entropy</span>
<span class="sd">    H_Renyi : scalar</span>
<span class="sd">        Renyi entropy</span>
<span class="sd">    H_pairedShannon : scalar</span>
<span class="sd">        Paired Shannon entropy</span>
<span class="sd">    H_gamma : scalar</span>
<span class="sd">        Gamma entropy</span>
<span class="sd">    H_GiniSimpson : scalar</span>
<span class="sd">        Gini Simpson entropy</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    1. Zhao, Yueqin. &quot;Rao&#39;s Quadratic Entropy and Some New Applications&quot; (2010). </span>
<span class="sd">    Doctor of Philosophy (PhD), dissertation,Mathematics and Statistics, </span>
<span class="sd">    Old Dominion University, DOI: 10.25777/qgak-sf09</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Compute entropy in time domain.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; env = maad.sound.envelope(s)</span>
<span class="sd">    &gt;&gt;&gt; Ht_Havrda, Ht_Renyi, Ht_pairedShannon, Ht_gamma, Ht_GiniSimpson = maad.features.more_entropy(env**2, order=3)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Ht_Havrda: %2.2f / Ht_Renyi: %2.2f / Ht_pairedShannon: %2.2f / Ht_gamma: %2.0f / Ht_GiniSimpson: %2.2f&#39; % (Ht_Havrda, Ht_Renyi, Ht_pairedShannon, Ht_gamma, Ht_GiniSimpson))</span>
<span class="sd">    Ht_Havrda: 0.33 / Ht_Renyi: 7.20 / Ht_pairedShannon: 9.04 / Ht_gamma: 24223924 / Ht_GiniSimpson: 1.00</span>
<span class="sd">    </span>
<span class="sd">    Compute entropy in spectral domain.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,_,_,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; S_power = maad.sound.avg_power_spectro(Sxx_power)</span>
<span class="sd">    &gt;&gt;&gt; Hf_Havrda, Hf_Renyi, Hf_pairedShannon, Hf_gamma, Hf_GiniSimpson = maad.features.more_entropy(S_power, order=3)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Hf_Havrda: %2.2f / Hf_Renyi: %2.2f / Hf_pairedShannon: %2.2f / Hf_gamma: %2.0f / Hf_GiniSimpson: %2.2f&#39; % (Hf_Havrda, Hf_Renyi, Hf_pairedShannon, Hf_gamma, Hf_GiniSimpson))</span>
<span class="sd">    Hf_Havrda: 0.33 / Hf_Renyi: 3.23 / Hf_pairedShannon: 4.92 / Hf_gamma: 7931 / Hf_GiniSimpson: 0.97</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="n">axis</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;WARNING: axis is to large, axis is set to 0&quot;</span><span class="p">)</span> 
            <span class="c1"># if datain contains negative values -&gt; rescale the signal between </span>
            <span class="c1"># between posSitive values (for example (0,1))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">linear_scale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">minval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">maxval</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Tranform the signal into a Probability mass function (pmf)</span>
            <span class="c1"># Sum(pmf) = 1</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="n">pmf</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>                     
                <span class="n">pmf</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">pmf</span><span class="p">[</span><span class="n">pmf</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_MIN_</span>
            <span class="c1"># alpha order entropy of Havrda and Charvat</span>
            <span class="n">H_Havrda</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="o">**</span><span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># alpha order entropy of Renyi</span>
            <span class="n">H_Renyi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="o">**</span><span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">order</span><span class="p">)</span>
            <span class="c1"># paired Shannon entropy</span>
            <span class="n">H_pairedShannon</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">pmf</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">pmf</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pmf</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="c1"># gamma entropy</span>
            <span class="n">H_gamma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">order</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span><span class="o">**</span><span class="n">order</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1"># Gini-Simpson entropy</span>
            <span class="n">H_GiniSimpson</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pmf</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>           
                
    <span class="k">return</span> <span class="n">H_Havrda</span><span class="p">,</span> <span class="n">H_Renyi</span><span class="p">,</span> <span class="n">H_pairedShannon</span><span class="p">,</span> <span class="n">H_gamma</span><span class="p">,</span> <span class="n">H_GiniSimpson</span></div>

<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="frequency_raoq"><a class="viewcode-back" href="../../../generated/maad.features.frequency_raoQ.html#maad.features.frequency_raoq">[docs]</a><span class="k">def</span> <span class="nf">frequency_raoq</span> <span class="p">(</span><span class="n">S_power</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Rao&#39;s quadratic entropy on a power spectrum (1d).</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    S_power : ndarray of floats </span>
<span class="sd">        Spectrum (1d)</span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        frequency vector</span>
<span class="sd">    bin_step : scalar, optional, default is 1000</span>
<span class="sd">        Frequency step in Hz</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    RAOQ : scalar</span>
<span class="sd">        Rao quadratic entropy  </span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ---------</span>
<span class="sd">    </span>
<span class="sd">    1. Zhao, Yueqin. &quot;Rao&#39;s Quadratic Entropy and Some New Applications&quot; (2010). Doctor of Philosophy (PhD) dissertation, Mathematics and Statistics, Old Dominion University, DOI: 10.25777/qgak-sf09</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/spinetail.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; S_power = maad.sound.avg_power_spectro(Sxx_power) </span>
<span class="sd">    &gt;&gt;&gt; maad.features.frequency_raoq(S_power, fn)</span>
<span class="sd">    0.10556621228886422</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># be sure they are ndarray</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">S_power</span><span class="p">)</span>    

    <span class="c1">#Convert into bins</span>
    <span class="n">X_bins</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">into_bins</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">bin_min</span><span class="o">=</span><span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_max</span><span class="o">=</span><span class="n">fn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                            <span class="n">bin_step</span><span class="o">=</span><span class="n">bin_step</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> 
              
    <span class="c1"># Compute Rao Quadratic Entropy</span>
    <span class="n">RAOQ</span> <span class="o">=</span> <span class="n">_raoQ</span><span class="p">(</span><span class="n">X_bins</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">RAOQ</span></div>

<span class="c1">#=============================================================================    </span>

<div class="viewcode-block" id="tfsd"><a class="viewcode-back" href="../../../generated/maad.features.tfsd.html#maad.features.tfsd">[docs]</a><span class="k">def</span> <span class="nf">tfsd</span> <span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">flim</span><span class="o">=</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span><span class="mi">8000</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;thirdOctave&#39;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Time frequency derivation index (tfsd) from a spectrogram.</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx : ndarray of floats</span>
<span class="sd">        matrix : Spectrogram  </span>
<span class="sd">    fn : vector</span>
<span class="sd">        frequency vector corresponding to the spectrogram</span>
<span class="sd">    tn : vector</span>
<span class="sd">        time vector corresponding to the spectrogram </span>
<span class="sd">    flim : tupple (fmin, fmax), optional, default is (2000, 8000)</span>
<span class="sd">        Frequency band used to compute tfsd. </span>
<span class="sd">    mode : string {&#39;thirdOctave&#39;,&#39;Octave&#39;}, default is thirdOctave  </span>
<span class="sd">        Select the way to transform the spectrogram with linear bands into </span>
<span class="sd">        octave bands    </span>
<span class="sd">    display : boolean, optional, default is False</span>
<span class="sd">        Display the 1st and 2nd derivation of the spectrogram</span>

<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    tfsd : scalar</span>
<span class="sd">        Time frequency derivation index</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The higher the TFSD varies between 0 and 1, the greater the temporal </span>
<span class="sd">    presence of avian or human vocalizations.  </span>
<span class="sd">    With the default configuration, a TFSD &gt; 0.3 indicates a very important </span>
<span class="sd">    presence time of the vocalizations in the signal. </span>
<span class="sd">    The TFSD is always greater than 0.</span>
<span class="sd">       </span>
<span class="sd">    References </span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Aumond, P., Can, A., De Coensel, B., Botteldooren, D., Ribeiro, C., &amp; Lavandier, C. (2017). </span>
<span class="sd">    Modeling soundscape pleasantness using perceptual assessments and acoustic measurements </span>
<span class="sd">    along paths in urban context. Acta Acustica united with Acustica,</span>
<span class="sd">    .. [2] Gontier, F., Lavandier, C., Aumond, P., Lagrange, M., &amp; Petiot, J. F. (2019). </span>
<span class="sd">    Estimation of the perceived time of presence of sources in urban acoustic environments </span>
<span class="sd">    using deep learning techniques. Acta Acustica united with Acustica,</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    During the day</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; maad.features.tfsd(Sxx_power,fn, tn)  </span>
<span class="sd">    0.5002113200343906</span>
<span class="sd">    </span>
<span class="sd">    During the night</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_night.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; maad.features.tfsd(Sxx_power,fn, tn)  </span>
<span class="sd">    0.012818445992714088</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert into 1/3 octave</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;thirdOctave&#39;</span> <span class="p">:</span> 
        <span class="n">x</span><span class="p">,</span> <span class="n">fn_bin</span> <span class="o">=</span> <span class="n">linear_to_octave</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">thirdOctave</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;Octave&#39;</span> <span class="p">:</span> 
        <span class="n">x</span><span class="p">,</span> <span class="n">fn_bin</span> <span class="o">=</span> <span class="n">linear_to_octave</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">thirdOctave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>   

    <span class="c1"># Derivation along the time axis, for each frequency bin</span>
    <span class="n">GRADdt</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Derivation of the previously derivated matrix along the frequency axis </span>
    <span class="n">GRADdf</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">GRADdt</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># select the bandwidth</span>
    <span class="k">if</span> <span class="n">flim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">GRADdf_select</span> <span class="o">=</span> <span class="n">GRADdf</span><span class="p">[</span><span class="n">index_bw</span><span class="p">(</span><span class="n">fn_bin</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">bw</span><span class="o">=</span><span class="n">flim</span><span class="p">),]</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="n">GRADdf_select</span> <span class="o">=</span> <span class="n">GRADdf</span>    
    
    <span class="c1"># calcul of the tfsdt : sum of the pseudo-gradient in the frequency bandwidth</span>
    <span class="c1"># which is normalized by the total sum of the pseudo-gradient</span>
    <span class="n">tfsd</span> <span class="o">=</span>  <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">GRADdf_select</span><span class="p">))</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">GRADdf</span><span class="p">))</span> 
    
    <span class="k">if</span> <span class="n">display</span> <span class="p">:</span>
        
            <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fn_bin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fn_bin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
            <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># set the paramteers of the figure</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_figheight</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_figwidth</span> <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
                    
            <span class="c1"># display image</span>
            <span class="n">_im1</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">power2dB</span><span class="p">(</span><span class="n">GRADdt</span><span class="p">),</span> 
                              <span class="n">vmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">power2dB</span><span class="p">(</span><span class="n">GRADdt</span><span class="p">)),</span> 
                              <span class="n">vmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">power2dB</span><span class="p">(</span><span class="n">GRADdt</span><span class="p">)),</span>
                              <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> 
                              <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">_im1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
            
            <span class="c1"># set the parameters of the subplot</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Derivation along time axis&#39;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>   
            <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span> 
            
            <span class="c1"># display image</span>
            <span class="n">_im2</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">power2dB</span><span class="p">(</span><span class="n">GRADdf</span><span class="p">),</span> 
                              <span class="n">vmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">power2dB</span><span class="p">(</span><span class="n">GRADdf</span><span class="p">)),</span> 
                              <span class="n">vmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">power2dB</span><span class="p">(</span><span class="n">GRADdf</span><span class="p">)),</span>
                              <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> 
                              <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">_im2</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
       
            <span class="c1"># set the parameters of the subplot</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Derivation along frequency axis&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span> 
         
            <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
             
            <span class="c1"># Display the figure now</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">tfsd</span></div>

<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="acoustic_gradient_index"><a class="viewcode-back" href="../../../generated/maad.features.acoustic_gradient_index.html#maad.features.acoustic_gradient_index">[docs]</a><span class="k">def</span> <span class="nf">acoustic_gradient_index</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;per_bin&#39;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Acoustic Gradient Index (AGI) from a raw spectrogram.</span>
<span class="sd">    </span>
<span class="sd">    This index must be computed on a raw spectrogram (background noise must remain).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx : ndarray of floats</span>
<span class="sd">        2d : Spectrogram </span>
<span class="sd">    dt : float</span>
<span class="sd">        Time resolution in seconds. </span>
<span class="sd">    norm : string, optional, default is &#39;per_bin&#39;</span>
<span class="sd">        Determine if the AGI is normalized by the global meaian value </span>
<span class="sd">        (&#39;global&#39; mode) or by the median value per frequency bin </span>
<span class="sd">        (&#39;per_bin&#39;)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    AGI_xx : 2d ndarray of scalars</span>
<span class="sd">        Acoustic Gradient Index of the spectrogram</span>
<span class="sd">    AGI_per_bin : 1d ndarray of scalars</span>
<span class="sd">        AGI value for each frequency bin</span>
<span class="sd">        sum(AGI_xx,axis=1)  </span>
<span class="sd">    AGI_sum : scalar</span>
<span class="sd">        Sum of AGI value per frequency bin (Common definition)</span>
<span class="sd">        sum(AGI_per_bin)  </span>
<span class="sd">    AGI_mean ; scalar</span>
<span class="sd">        average AGI value per frequency bin (independant of the number of </span>
<span class="sd">        frequency bin)</span>
<span class="sd">        mean(AGI_per_bin)</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    During the day</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; _, _, AGI_mean, _ = maad.features.acoustic_gradient_index(Sxx_power,tn[1]-tn[0])</span>
<span class="sd">    &gt;&gt;&gt; AGI_mean</span>
<span class="sd">    5.026112548525072</span>
<span class="sd">    </span>
<span class="sd">    During the night</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_night.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; _, _, AGI_mean, _ = maad.features.acoustic_gradient_index(Sxx_power,tn[1]-tn[0])</span>
<span class="sd">    &gt;&gt;&gt; AGI_mean</span>
<span class="sd">    1.45631461307782  </span>
<span class="sd">     </span>
<span class="sd">    &quot;&quot;&quot;</span>     
    <span class="c1"># derivative (order = 1, 2, 3...)</span>
    <span class="n">AGI_xx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">Sxx</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="n">order</span> <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="c1"># Normalize the derivative by the median derivative which should </span>
        <span class="c1"># correspond to the background (noise) derivative</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span><span class="s1">&#39;per_bin&#39;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">AGI_xx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    
            <span class="n">m</span><span class="p">[</span><span class="n">m</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_MIN_</span>    <span class="c1"># Avoid dividing by zero value</span>
            <span class="n">AGI_xx</span> <span class="o">=</span> <span class="n">AGI_xx</span><span class="o">/</span><span class="n">m</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">AGI_xx</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_MIN_</span> 
            <span class="n">AGI_xx</span> <span class="o">=</span> <span class="n">AGI_xx</span><span class="o">/</span><span class="n">m</span>

    <span class="c1"># mean per bin </span>
    <span class="n">AGI_per_bin</span> <span class="o">=</span> <span class="n">mean</span> <span class="p">(</span><span class="n">AGI_xx</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
    <span class="c1"># Mean global</span>
    <span class="n">AGI_mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">AGI_per_bin</span><span class="p">)</span> 
    <span class="c1"># global sum</span>
    <span class="n">AGI_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">AGI_per_bin</span><span class="p">)</span> 

    <span class="c1"># display full SPECTROGRAM in dB</span>
    <span class="k">if</span> <span class="n">display</span><span class="o">==</span><span class="kc">True</span> <span class="p">:</span>
        
        <span class="n">fig4</span><span class="p">,</span> <span class="n">ax4</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="c1"># set the paramteers of the figure</span>
        <span class="n">fig4</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">fig4</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="n">fig4</span><span class="o">.</span><span class="n">set_figheight</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">fig4</span><span class="o">.</span><span class="n">set_figwidth</span> <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
                
        <span class="c1"># display image</span>
        <span class="n">_im</span> <span class="o">=</span> <span class="n">ax4</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">power2dB</span><span class="p">(</span><span class="n">Sxx</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> 
                         <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> 
                         <span class="n">vmin</span> <span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">_im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax4</span><span class="p">)</span>
 
        <span class="c1"># set the parameters of the subplot</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Spectrogram&#39;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [sec]&#39;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency [Hz]&#39;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span> 
     
        <span class="n">fig4</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
         
        <span class="c1"># Display the figure now</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">AGI_xx</span><span class="p">,</span> <span class="n">AGI_per_bin</span><span class="p">,</span> <span class="n">AGI_mean</span><span class="p">,</span> <span class="n">AGI_sum</span></div>

<span class="c1">#=============================================================================</span>

<div class="viewcode-block" id="region_of_interest_index"><a class="viewcode-back" href="../../../generated/maad.features.region_of_interest_index.html#maad.features.region_of_interest_index">[docs]</a><span class="k">def</span> <span class="nf">region_of_interest_index</span><span class="p">(</span><span class="n">Sxx_dB_noNoise</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> 
                          <span class="n">smooth_param1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask_mode</span><span class="o">=</span><span class="s1">&#39;relative&#39;</span><span class="p">,</span> 
                          <span class="n">mask_param1</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">mask_param2</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> 
                          <span class="n">min_roi</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">max_roi</span><span class="o">=</span><span class="mi">512</span><span class="o">*</span><span class="mi">10000</span><span class="p">,</span> 
                          <span class="n">remove_rain</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute an acoustic activity index based on the regions of interested detected on a spectrogram.</span>
<span class="sd">    </span>
<span class="sd">    The function first find regions of interest (ROI) and then compute the number and cover area </span>
<span class="sd">    on the spectrogram.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx_dB_noNoise : ndarray of floats</span>
<span class="sd">        Spectrogram without noise (i.e matrix of spectrum)</span>
<span class="sd">    tn : 1d ndarray of floats</span>
<span class="sd">        time vector (horizontal x-axis)</span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        Frequency vector (vertical y-axis) </span>
<span class="sd">    smooth_param1 : scalar, default is 1</span>
<span class="sd">        Standard deviation of the gaussian kernel used to smooth the image </span>
<span class="sd">        The larger is the number, the smoother will be the image and the longer </span>
<span class="sd">        it takes. Standard values should fall between 0.5 to 3 </span>
<span class="sd">    mask_mode : string in {&#39;relative&#39;, &#39;absolute&#39;}, optional, default is &#39;relative&#39;</span>
<span class="sd">        if &#39;relative&#39;:</span>
<span class="sd">            Binarize an image based on a double relative threshold.  </span>
<span class="sd">            The values used for the thresholding depends on the values found </span>
<span class="sd">            in the image. =&gt; relative threshold </span>
<span class="sd">        if &#39;absolute&#39; :</span>
<span class="sd">            Binarize an image based on a double relative threshold.  </span>
<span class="sd">            The values used for the thresholding are independent of the values </span>
<span class="sd">            in the image =&gt; absolute threshold </span>
<span class="sd">    mask_param1 : scalar, default is 6</span>
<span class="sd">        if &#39;relative&#39; : bin_h</span>
<span class="sd">        if &#39;absolute&#39; : bin_std</span>
<span class="sd">    mask_param2 : scalar, default is 0.5</span>
<span class="sd">        if &#39;relative&#39; : bin_l</span>
<span class="sd">        if &#39;absolute&#39; : bin_per</span>
<span class="sd">    min_roi, max_roi : scalars, optional, default : 9,  512*10000</span>
<span class="sd">        Define the minimum and the maximum area possible for an ROI. If None,  </span>
<span class="sd">        the minimum ROI area is 1 pixel and the maximum ROI area is the area of  </span>
<span class="sd">        the image    </span>
<span class="sd">    remove_rain : boolean, default is False</span>
<span class="sd">        If True, vertical frequency spikes due to rain are removed as possible</span>
<span class="sd">        by applying a morphological mathematical image processing : grey opening</span>
<span class="sd">    display : boolean, default is false</span>
<span class="sd">        plot graphs and spectrograms</span>
<span class="sd">    /*/*kwargs optional. This parameter is used by plt.plot and savefig functions </span>

<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    ROItotal : float</span>
<span class="sd">         Total number of ROIs found. The higher is the number of ROI, the higher</span>
<span class="sd">         is the acoustic abondance and/or richness expected</span>
<span class="sd">    ROIcover : float</span>
<span class="sd">        Percentage of spectrogram cover. The higher is the cover percentage, </span>
<span class="sd">        the higher is the acoustic richness expected.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    -------- </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,_ = maad.sound.spectrogram(s,fs)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_noNoise= maad.sound.median_equalizer(Sxx_power) </span>
<span class="sd">    &gt;&gt;&gt; Sxx_dB_noNoise = maad.util.power2dB(Sxx_noNoise)</span>
<span class="sd">    &gt;&gt;&gt; ROItotal, ROIcover = maad.features.region_of_interest_index(Sxx_dB_noNoise, tn, fn, display=True)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;The total number of ROIs found in the spectrogram is %2.0f&#39; %ROItotal)</span>
<span class="sd">    The total number of ROIs found in the spectrogram is 265</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;The percentage of spectrogram covered by ROIs is %2.0f%%&#39; %ROIcover)</span>
<span class="sd">    The percentage of spectrogram covered by ROIs is 12%</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># extent</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;extent&#39;</span><span class="p">:(</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    
    <span class="c1"># if remove rain =&gt; remove frequential spikes (rain)</span>
    <span class="k">if</span> <span class="n">remove_rain</span> <span class="o">==</span> <span class="kc">True</span> <span class="p">:</span>
        <span class="n">Sxx_dB_noNoise</span> <span class="o">=</span> <span class="n">opening</span><span class="p">(</span><span class="n">Sxx_dB_noNoise</span><span class="p">,</span> <span class="n">selem</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>

    <span class="c1"># Smooth the spectrogram in order to facilitate the creation of masks</span>
    <span class="n">Sxx_dB_noNoise_smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">Sxx_dB_noNoise</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">smooth_param1</span><span class="p">,</span> 
                         <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> 
    <span class="c1"># binarization of the spectrogram to select part of the spectrogram with </span>
    <span class="c1"># acoustic activity</span>
    <span class="k">if</span> <span class="n">mask_mode</span> <span class="o">==</span> <span class="s1">&#39;relative&#39;</span> <span class="p">:</span>
        <span class="n">im_mask</span> <span class="o">=</span> <span class="n">create_mask</span><span class="p">(</span><span class="n">Sxx_dB_noNoise_smooth</span><span class="p">,</span>  
                              <span class="n">mode_bin</span> <span class="o">=</span> <span class="s1">&#39;relative&#39;</span><span class="p">,</span> <span class="n">bin_std</span><span class="o">=</span><span class="n">mask_param1</span><span class="p">,</span> 
                              <span class="n">bin_per</span><span class="o">=</span><span class="n">mask_param2</span><span class="p">,</span>
                              <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> 
    <span class="k">elif</span>  <span class="n">mask_mode</span> <span class="o">==</span> <span class="s1">&#39;absolute&#39;</span> <span class="p">:</span>   
        <span class="n">im_mask</span> <span class="o">=</span> <span class="n">create_mask</span><span class="p">(</span><span class="n">Sxx_dB_noNoise_smooth</span><span class="p">,</span>  
                              <span class="n">mode_bin</span> <span class="o">=</span> <span class="s1">&#39;absolute&#39;</span><span class="p">,</span> <span class="n">bin_h</span><span class="o">=</span><span class="n">mask_param1</span><span class="p">,</span> 
                              <span class="n">bin_l</span><span class="o">=</span><span class="n">mask_param2</span><span class="p">,</span>
                              <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span> <span class="p">(</span><span class="s1">&#39;mask_mode should be selected in {relative, absolute}&#39;</span><span class="p">)</span>
            
    <span class="c1"># get the mask with rois (im_rois) and the bounding box for each rois (rois_bbox) </span>
    <span class="c1"># and an unique index for each rois =&gt; in the pandas dataframe rois</span>
    <span class="n">im_rois</span><span class="p">,</span> <span class="n">rois</span>  <span class="o">=</span> <span class="n">select_rois</span><span class="p">(</span><span class="n">im_mask</span><span class="p">,</span><span class="n">min_roi</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> 
                                 <span class="n">display</span><span class="o">=</span> <span class="n">display</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1">##### Extract centroids features of each roi from the spectrogram in dB without noise </span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">dB2power</span><span class="p">(</span><span class="n">Sxx_dB_noNoise</span><span class="p">)</span>
    <span class="n">rois</span> <span class="o">=</span> <span class="n">format_features</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span> 
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">centroid_features</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">rois</span><span class="p">,</span> <span class="n">im_rois</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">display</span> <span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Sxx_dB_noNoise</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;vmax&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">)})</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;vmin&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X</span><span class="p">)})</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">fig</span> <span class="o">=</span> <span class="n">overlay_rois</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">rois</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
 
<span class="c1">#        dpi= 96</span>
<span class="c1">#        bbox_inches= &#39;tight&#39;</span>
<span class="c1">#        format=&#39;png&#39;</span>
<span class="c1">#        savefilename=&#39;_spectrogram_bounding_box&#39;</span>
<span class="c1">#        filename = savefile+savefilename+&#39;.&#39;+format</span>
<span class="c1">#        print(&#39;\n&#39;&#39;save figure : %s&#39; %filename)</span>
<span class="c1">#        fig20.savefig(fname=filename, dpi=dpi, bbox_inches=bbox_inches,</span>
<span class="c1">#                    format=format)  </span>

    <span class="c1">#ROItotal</span>
    <span class="n">ROItotal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span>
    
    <span class="c1">##### calcul the area of each roi</span>
    <span class="c1"># rectangular area (overestimation)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">max_y</span> <span class="o">-</span><span class="n">rois</span><span class="o">.</span><span class="n">min_y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rois</span><span class="o">.</span><span class="n">max_x</span> <span class="o">-</span><span class="n">rois</span><span class="o">.</span><span class="n">min_x</span><span class="p">)</span>
    <span class="c1"># size of im_rois =&gt; whole spectrogram</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">im_rois</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">total_area</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>
    <span class="c1"># Pourcentage of ROI over the total area</span>
    <span class="n">ROIcover</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_area</span> <span class="o">*</span><span class="mi">100</span>
    
    <span class="k">return</span>  <span class="n">ROItotal</span><span class="p">,</span> <span class="n">ROIcover</span></div>


<span class="c1">#=============================================================================</span>
<div class="viewcode-block" id="all_temporal_alpha_indices"><a class="viewcode-back" href="../../../generated/maad.features.all_temporal_alpha_indices.html#maad.features.all_temporal_alpha_indices">[docs]</a><span class="k">def</span> <span class="nf">all_temporal_alpha_indices</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute 16 temporal domain acoustic indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : 1D array</span>
<span class="sd">        Audio to process (wav)</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling frequency of the audio (Hz)</span>
<span class="sd">    verbose : boolean, default is False</span>
<span class="sd">        print indices on the default terminal</span>
<span class="sd">    display : boolean, default is False</span>
<span class="sd">        Display graphs</span>
<span class="sd">    \*\*kwargs : arguments for functions :</span>
<span class="sd">        - temporal_leq(s, fs, gain, Vadc, sensitivity, dBref, dt)</span>
<span class="sd">        - temporal_snr(s, mode, Nt) </span>
<span class="sd">        - temporal_median(s, mode, Nt)</span>
<span class="sd">        - temporal_entropy(s, compatibility, mode, Nt)</span>
<span class="sd">        - temporal_activity (s,dB_threshold, mode, Nt)</span>
<span class="sd">        - temporal_events (s, fs, dB_threshold, rejectDuration, mode, Nt,display)</span>
<span class="sd">    </span>
<span class="sd">        For envelope</span>
<span class="sd">        mode : str, optional, default is &quot;fast&quot;</span>
<span class="sd">            Select the mode to compute the envelope of the audio waveform</span>
<span class="sd">            - &quot;fast&quot; : The sound is first divided into frames (2d) using the </span>
<span class="sd">                function _wave2timeframes(s), then the max of each frame gives a </span>
<span class="sd">                good approximation of the envelope.</span>
<span class="sd">            - &quot;Hilbert&quot; : estimation of the envelope from the Hilbert transform. </span>
<span class="sd">                The method is slow</span>
<span class="sd">        Nt : integer, optional, default is 512</span>
<span class="sd">            Size of each frame. The largest, the highest is the approximation.</span>
<span class="sd">            </span>
<span class="sd">        For entropy</span>
<span class="sd">        compatibility : string {&#39;QUT&#39;, &#39;seewave&#39;}, default is &#39;QUT&#39;</span>
<span class="sd">            Select the way to compute the temporal entropy.</span>
<span class="sd">                - QUT : entropy of the envelope²</span>
<span class="sd">                - seewave : entropy of the envelope</span>
<span class="sd">                </span>
<span class="sd">        For LEQt calculation</span>
<span class="sd">        gain : integer</span>
<span class="sd">            Total gain applied to the sound (preamplifer + amplifier)</span>
<span class="sd">        Vadc : scalar, optional, default is 2Vpp (=&gt;+/-1V)</span>
<span class="sd">            Maximal voltage (peak to peak) converted by the analog to digital convertor ADC    </span>
<span class="sd">        sensitivity : float, optional, default is -35 (dB/V)</span>
<span class="sd">            Sensitivity of the microphone</span>
<span class="sd">        dBref : integer, optional, default is 94 (dBSPL)</span>
<span class="sd">            Pressure sound level used for the calibration of the microphone </span>
<span class="sd">            (usually 94dB, sometimes 114dB)</span>
<span class="sd">        dt : float, optional, default is 1 (second)</span>
<span class="sd">            Integration step to compute the Leq (Equivalent Continuous Sound level) </span>
<span class="sd">        </span>
<span class="sd">        for audio activity and events</span>
<span class="sd">        dB_threshold : scalar, optional, default is 3dB</span>
<span class="sd">            data &gt;Threshold is considered to be an event </span>
<span class="sd">            if the length is &gt; rejectLength</span>
<span class="sd">        rejectDuration : scalar, optional, default is None</span>
<span class="sd">            event shorter than rejectDuration are discarded</span>
<span class="sd">            duration is in s</span>
<span class="sd">   </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_temporal_indices: Panda dataframe</span>
<span class="sd">       Dataframe containing of the calculated audio indices : ZCR, MEANt, </span>
<span class="sd">       VARt, SKEWt, KURTt, LEQt, BGNt, SNRt, MED, Ht, ACTtFraction, </span>
<span class="sd">       ACTtCount, ACTtMean, EVNtFraction, EVNtMean, EVNtCount</span>
<span class="sd">           </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    temporal_moments, temporal_events, temporal_activity, temporal_entropy, </span>
<span class="sd">    temporal_median, temporal_leq, temporal_snr, zero_crossing_rate</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_night.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; df_tempora_indices_NIGHT = maad.features.all_temporal_alpha_indices (s,fs)</span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; df_temporal_indices_DAY = maad.features.all_temporal_alpha_indices (s,fs)</span>
<span class="sd">    </span>
<span class="sd">    Variation between night and day</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; var = abs(df_temporal_indices_DAY - df_temporal_indices_NIGHT)/df_temporal_indices_NIGHT*100</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;LEQt var night vs day: %2.2f %%&#39; % var.LEQt)</span>
<span class="sd">    LEQt var : 29.66 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Ht var night vs day: %2.2f %%&#39; % var.Ht)</span>
<span class="sd">    Ht var : 2.33 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;MEANt var night vs day: %2.2f %%&#39; % var.MEANt)</span>
<span class="sd">    MEANt var night vs day: 299.62 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;VARt var night vs day: %2.2f %%&#39; % var.VARt)</span>
<span class="sd">    VARt var night vs day: 1664.02 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;EVNtFraction var night vs day: %2.2f %%&#39; % var.EVNtFraction)</span>
<span class="sd">    EVNtFraction var night vs day: 98.48 %</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#### get variables</span>
    <span class="c1"># Envelope =&gt; mode {&#39;fast&#39;, &#39;hilbert&quot;}, if &#39;fast&#39;, set Nt, number of point by frame </span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span><span class="s1">&#39;fast&#39;</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;Nt&#39;</span><span class="p">,</span><span class="mi">512</span><span class="p">)</span>
    
    <span class="c1"># for entropy : compatibility {&#39;QUT&#39;, &#39;seewave&#39;}</span>
    <span class="n">compatibility</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;compatibility&#39;</span><span class="p">,</span><span class="s1">&#39;QUT&#39;</span><span class="p">)</span> 
    
    <span class="c1"># for LEQ : </span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gain&#39;</span><span class="p">,</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">Vadc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;Vadc&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dt&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sensitivity&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">35</span><span class="p">)</span>
    <span class="n">dBref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dBref&#39;</span><span class="p">,</span><span class="mi">94</span><span class="p">)</span>
    
    <span class="c1"># for audio activity and events</span>
    <span class="n">dB_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dB_threshold&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">rejectDuration</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rejectDuration&#39;</span><span class="p">,</span><span class="mf">0.01</span><span class="p">)</span>
    
    <span class="c1">#### create a list</span>
    <span class="n">df_temporal_indices</span><span class="o">=</span><span class="p">[]</span> 
    
    <span class="sd">&quot;&quot;&quot;************************* Zero Crossing Rate ************ ***********&quot;&quot;&quot;</span> 
    <span class="n">ZCR</span> <span class="o">=</span> <span class="n">zero_crossing_rate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ZCR</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ZCR </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ZCR</span><span class="p">)</span>
        
    <span class="sd">&quot;&quot;&quot;**************************** 4 audio moments *************************&quot;&quot;&quot;</span> 
    <span class="n">MEANt</span><span class="p">,</span> <span class="n">VARt</span><span class="p">,</span> <span class="n">SKEWt</span><span class="p">,</span> <span class="n">KURTt</span> <span class="o">=</span> <span class="n">temporal_moments</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">MEANt</span><span class="p">,</span> <span class="n">VARt</span><span class="p">,</span> <span class="n">SKEWt</span><span class="p">,</span> <span class="n">KURTt</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MEANt </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">MEANt</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;VARt </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">VARt</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SKEWt </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">SKEWt</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;KURTt </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">KURTt</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;********** total sound pressure level in temporal domain ***********&quot;&quot;&quot;</span> 
    <span class="n">LEQt</span> <span class="o">=</span> <span class="n">temporal_leq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">Vadc</span><span class="p">,</span> <span class="n">sensitivity</span><span class="p">,</span> <span class="n">dBref</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">LEQt</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LEQt </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">LEQt</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;************ Signal to noise Ratio and noise energy   *************&quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span><span class="n">BGNt</span><span class="p">,</span><span class="n">SNRt</span> <span class="o">=</span> <span class="n">temporal_snr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>  
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">BGNt</span><span class="p">,</span> <span class="n">SNRt</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SNRt </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">SNRt</span><span class="p">)</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BGNt </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">BGNt</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;*********************** median energy   ***************************&quot;&quot;&quot;</span>
    <span class="n">MED</span> <span class="o">=</span>  <span class="n">temporal_median</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">MED</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MED </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">MED</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;*******************  energy concentration : entropy****************&quot;&quot;&quot;</span>
    <span class="n">Ht</span> <span class="o">=</span>  <span class="n">temporal_entropy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">compatibility</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Ht</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ht </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">Ht</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;**************************** Acoustic activity ********************&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot; ACT &amp; EVN [TOWSEY] &quot;&quot;&quot;</span>
    <span class="n">ACTtFraction</span><span class="p">,</span> <span class="n">ACTtCount</span><span class="p">,</span> <span class="n">ACTtMean</span> <span class="o">=</span> <span class="n">temporal_activity</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">dB_threshold</span><span class="p">,</span>
                                                        <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ACTtFraction</span><span class="p">,</span> <span class="n">ACTtCount</span><span class="p">,</span> <span class="n">ACTtMean</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACTtFraction </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ACTtFraction</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACTtCount </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ACTtCount</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACTtMean </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ACTtMean</span><span class="p">)</span>
    
    <span class="n">EVNtFraction</span><span class="p">,</span> <span class="n">EVNtMean</span><span class="p">,</span> <span class="n">EVNtCount</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">temporal_events</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="p">,</span>
                                                         <span class="n">rejectDuration</span><span class="p">,</span>
                                                         <span class="n">mode</span><span class="p">,</span> <span class="n">Nt</span><span class="p">,</span>
                                                         <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>
    <span class="n">df_temporal_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">EVNtFraction</span><span class="p">,</span> <span class="n">EVNtMean</span><span class="p">,</span> <span class="n">EVNtCount</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>    
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EVNtFraction </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">EVNtFraction</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EVNtMean </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">EVNtMean</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EVNtCount </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">EVNtCount</span><span class="p">)</span>
    
    <span class="n">df_temporal_indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">df_temporal_indices</span><span class="p">],</span> 
                                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ZCR&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;MEANt&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;VARt&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;SKEWt&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;KURTt&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;LEQt&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;BGNt&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;SNRt&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;MED&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;Ht&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;ACTtFraction&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;ACTtCount&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;ACTtMean&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;EVNtFraction&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;EVNtMean&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;EVNtCount&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">df_temporal_indices</span></div>


<div class="viewcode-block" id="all_spectral_alpha_indices"><a class="viewcode-back" href="../../../generated/maad.features.all_spectral_alpha_indices.html#maad.features.all_spectral_alpha_indices">[docs]</a><span class="k">def</span> <span class="nf">all_spectral_alpha_indices</span> <span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span>
                      <span class="n">flim_low</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1000</span><span class="p">],</span> 
                      <span class="n">flim_mid</span><span class="o">=</span><span class="p">[</span><span class="mi">1000</span><span class="p">,</span><span class="mi">10000</span><span class="p">],</span> 
                      <span class="n">flim_hi</span><span class="o">=</span><span class="p">[</span><span class="mi">10000</span><span class="p">,</span><span class="mi">20000</span><span class="p">],</span> 
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the acoustic indices in spectral (spectrum (1d) or spectrogram (2d)) domain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Sxx_power : 2D array of floats</span>
<span class="sd">        Power spectrogram to process (taken directly from maad.sound.spectrogram)</span>
<span class="sd">    tn : 1d ndarray of floats</span>
<span class="sd">        time vector (horizontal x-axis)</span>
<span class="sd">    fn : 1d ndarray of floats</span>
<span class="sd">        Frequency vector (vertical y-axis)</span>
<span class="sd">    flim_low : tupple, optional, default is (0,1000)</span>
<span class="sd">        Low frequency band in Hz</span>
<span class="sd">    flim_mid : tupple, optional, default is (1000,10000)</span>
<span class="sd">        mid frequency band in Hz</span>
<span class="sd">    flim_hi : tupple, optional, default is (10000,20000)</span>
<span class="sd">        high frequency band in Hz        </span>
<span class="sd">    verbose : boolean, default is False</span>
<span class="sd">        print indices on the default terminal</span>
<span class="sd">    display : boolean, default is False</span>
<span class="sd">        Display graphs</span>
<span class="sd">    \*\*kwargs : arguments for functions :</span>
<span class="sd">                spectral_leq</span>
<span class="sd">                frequency_entropy</span>
<span class="sd">                soundscape_index</span>
<span class="sd">                bioacoustics_index</span>
<span class="sd">                acoustic_diversity_index</span>
<span class="sd">                acoustic_eveness_index</span>
<span class="sd">                spectral_cover</span>
<span class="sd">                spectral_activity</span>
<span class="sd">                spectral_events</span>
<span class="sd">                tfsd</span>
<span class="sd">                region_of_interest_index</span>
<span class="sd">               </span>
<span class="sd">        For soundscape_index, bioacoustics_index, acoustic_diversity_index, acoustic_eveness_index</span>
<span class="sd">        R_compatible : string, optional, default is &quot;soundecology&quot;</span>
<span class="sd">            if &#39;soundecology&#39;, the result is similar to the package SoundEcology in R </span>
<span class="sd">            Otherwise, the result is specific to maad</span>
<span class="sd">                </span>
<span class="sd">        For LEQf calculation</span>
<span class="sd">        gain : integer</span>
<span class="sd">            Total gain applied to the sound (preamplifer + amplifier)</span>
<span class="sd">        Vadc : scalar, optional, default is 2Vpp (=&gt;+/-1V)</span>
<span class="sd">            Maximal voltage (peak to peak) converted by the analog to digital convertor ADC    </span>
<span class="sd">        sensitivity : float, optional, default is -35 (dB/V)</span>
<span class="sd">            Sensitivity of the microphone</span>
<span class="sd">        dBref : integer, optional, default is 94 (dBSPL)</span>
<span class="sd">            Pressure sound level used for the calibration of the microphone </span>
<span class="sd">            (usually 94dB, sometimes 114dB)</span>
<span class="sd">        pRef : Sound pressure reference in the medium (air : 20e-6, water : 1e-6)</span>
<span class="sd">        </span>
<span class="sd">        for spectral activity and events, ADI, AEI</span>
<span class="sd">        dB_threshold : scalar, optional, default is 3dB</span>
<span class="sd">            data &gt;Threshold is considered to be an event </span>
<span class="sd">            if the length is &gt; rejectLength</span>
<span class="sd">            </span>
<span class="sd">        for spectral activity and events</span>
<span class="sd">        rejectDuration : scalar, optional, default is None</span>
<span class="sd">            event shorter than rejectDuration are discarded</span>
<span class="sd">            duration is in s</span>
<span class="sd">            </span>
<span class="sd">        for Roi</span>
<span class="sd">        smooth_param1 : scalar, default is 1</span>
<span class="sd">            Standard deviation of the gaussian kernel used to smooth the image </span>
<span class="sd">            The larger is the number, the smoother will be the image and the longer </span>
<span class="sd">            it takes. Standard values should fall between 0.5 to 3 </span>
<span class="sd">        mask_mode : string in {&#39;relative&#39;, &#39;absolute&#39;}, optional, default is &#39;relative&#39;</span>
<span class="sd">            if &#39;relative&#39;:</span>
<span class="sd">                Binarize an image based on a double relative threshold.  </span>
<span class="sd">                The values used for the thresholding depends on the values found </span>
<span class="sd">                in the image. =&gt; relative threshold </span>
<span class="sd">            if &#39;absolute&#39; :</span>
<span class="sd">                Binarize an image based on a double relative threshold.  </span>
<span class="sd">                The values used for the thresholding are independent of the values </span>
<span class="sd">                in the image =&gt; absolute threshold </span>
<span class="sd">        mask_param1 : scalar, default is 6</span>
<span class="sd">            if &#39;relative&#39; : bin_h</span>
<span class="sd">            if &#39;absolute&#39; : bin_std</span>
<span class="sd">        mask_param2 : scalar, default is 0.5</span>
<span class="sd">            if &#39;relative&#39; : bin_l</span>
<span class="sd">            if &#39;absolute&#39; : bin_per</span>
<span class="sd">        remove_rain : boolean, default is False</span>
<span class="sd">            If True, most of spikes in spectrogram due to rain are removed using</span>
<span class="sd">            a math morphological method, the grey opening</span>
<span class="sd">        min_roi, max_roi : scalars, optional, default : 9,  512*10000</span>
<span class="sd">            Define the minimum and the maximum area possible for an ROI. If None,  </span>
<span class="sd">            the minimum ROI area is 1 pixel and the maximum ROI area is the area of  </span>
<span class="sd">            the image     </span>
<span class="sd">        </span>
<span class="sd">        for ADI, AEI, RAOQ</span>
<span class="sd">        bin_step : scalar, optional, default is 500</span>
<span class="sd">            Frequency step in Hz        </span>
<span class="sd">  </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_spectral_indices: Panda dataframe</span>
<span class="sd">        Dataframe containing of the calculated spectral indices :</span>
<span class="sd">    df_per_bin_indices : Panda dataframe</span>
<span class="sd">        Dataframe containing of the calculated spectral indices  per frequency</span>
<span class="sd">        bin :</span>
<span class="sd">           </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    number_of_peaks, spectral_leq, spectral_snr, frequency_entropy, </span>
<span class="sd">    spectral_entropy, acoustic_complexity_index, soundscape_index, soundscape_index,</span>
<span class="sd">    roughness, acoustic_diversity_index, acoustic_eveness_index, spectral_cover, </span>
<span class="sd">    spectral_activity, spectral_events, tfsd, more_entropy, frequency_raoq, </span>
<span class="sd">    acoustic_gradient_index, region_of_interest_index</span>

<span class="sd">    Examples</span>
<span class="sd">    --------    </span>
<span class="sd">    Spectral indices on a daylight recording</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_daylight.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,ext = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; df_spectral_indices_DAY, _ = maad.features.all_spectral_alpha_indices(Sxx_power,tn,fn,display=True, extent=ext)</span>
<span class="sd">    </span>
<span class="sd">    Spectral indices on a night recording</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; s, fs = maad.sound.load(&#39;../data/cold_forest_night.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sxx_power,tn,fn,ext = maad.sound.spectrogram (s, fs)  </span>
<span class="sd">    &gt;&gt;&gt; df_spectral_indices_NIGHT, _ = maad.features.all_spectral_alpha_indices(Sxx_power,tn,fn,display=True)</span>
<span class="sd">    </span>
<span class="sd">    Variation between night and day</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; var = abs(df_spectral_indices_DAY - df_spectral_indices_NIGHT)/df_spectral_indices_NIGHT*100</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;LEQf var night vs day: %2.2f %%&#39; % var.LEQf)</span>
<span class="sd">    LEQf var night vs day: 34.94 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;Hf var night vs day: %2.2f %%&#39; % var.Hf)</span>
<span class="sd">    Hf var night vs day: 105.61 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;ACI var night vs day: %2.2f %%&#39; % var.ACI)</span>
<span class="sd">    ACI var night vs day: 3.39 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;AGI var night vs day: %2.2f %%&#39; % var.AGI)</span>
<span class="sd">    AGI var night vs day: 20.50 %</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;ROItotal var night vs day: %2.2f %%&#39; % var.ROItotal)</span>
<span class="sd">    ROItotal var night vs day: 248.68 %</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># extent</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;extent&#39;</span><span class="p">:(</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    
    <span class="c1">#### get variables  </span>
    <span class="n">R_compatible</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;R_compatible&#39;</span><span class="p">,</span><span class="s1">&#39;soundecology&#39;</span><span class="p">)</span> 
    
    <span class="c1"># for LEQ : </span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;gain&#39;</span><span class="p">,</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">Vadc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;Vadc&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sensitivity&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">35</span><span class="p">)</span>
    <span class="n">dBref</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dBref&#39;</span><span class="p">,</span><span class="mi">94</span><span class="p">)</span>
    <span class="n">pRef</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pRef&#39;</span><span class="p">,</span><span class="mf">20e-6</span><span class="p">)</span>
    
    <span class="c1"># for audio activity and events</span>
    <span class="n">dB_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dB_threshold&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">rejectDuration</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rejectDuration&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># if None =&gt; 3 pixels</span>
    
    <span class="c1">### for Roi</span>
    <span class="n">min_roi_area</span>    <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;min_roi_area&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># if None =&gt;  30ms * 100Hz</span>
    <span class="n">smooth_param1</span>   <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;smooth_param1&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mask_mode</span>       <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mask_mode&#39;</span><span class="p">,</span><span class="s1">&#39;relative&#39;</span><span class="p">)</span>
    <span class="n">mask_param1</span>     <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mask_param1&#39;</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">mask_param2</span>     <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mask_param2&#39;</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">remove_rain</span>     <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;remove_rain&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1">### for ADI, AEI, RAOQ</span>
    <span class="n">bin_step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># in Hz</span>
    
    <span class="c1">#### create a list</span>
    <span class="n">df_spectral_indices</span><span class="o">=</span><span class="p">[]</span> 
    <span class="n">df_per_bin_indices</span><span class="o">=</span><span class="p">[]</span> 
    
    <span class="c1">### for flim to be ndarray</span>
    <span class="n">flim_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">flim_low</span><span class="p">)</span>
    <span class="n">flim_mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">flim_mid</span><span class="p">)</span>
    <span class="n">flim_hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">flim_hi</span><span class="p">)</span>
        
    <span class="c1">#### Prepare different spectrograms and spectrums</span>
    <span class="c1"># amplitude spectrogram</span>
    <span class="n">Sxx_amplitude</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">)</span>
    <span class="c1"># mean amplitude spectrum</span>
    <span class="n">S_amplitude</span> <span class="o">=</span> <span class="n">avg_amplitude_spectro</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">)</span>
    <span class="c1"># mean power spectrum</span>
    <span class="n">S_power</span> <span class="o">=</span> <span class="n">avg_power_spectro</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;************************* Long term spectrogram *********************&quot;&quot;&quot;</span>
    <span class="c1"># mean power spectrum =&gt; for long term spectrogram (LTS)</span>
    <span class="n">LTS</span> <span class="o">=</span> <span class="n">avg_power_spectro</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">)</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span><span class="p">[</span><span class="n">LTS</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    
    <span class="sd">&quot;&quot;&quot;**************************** 4 spectrum moments *********************&quot;&quot;&quot;</span> 
    <span class="n">MEANf</span><span class="p">,</span> <span class="n">VARf</span><span class="p">,</span> <span class="n">SKEWf</span><span class="p">,</span> <span class="n">KURTf</span> <span class="o">=</span> <span class="n">spectral_moments</span><span class="p">(</span><span class="n">S_amplitude</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">MEANf</span><span class="p">,</span> <span class="n">VARf</span><span class="p">,</span> <span class="n">SKEWf</span><span class="p">,</span> <span class="n">KURTf</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MEANf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">MEANf</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;VARf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">VARf</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SKEWf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">SKEWf</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;KURTf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">KURTf</span><span class="p">)</span>
     
    <span class="sd">&quot;&quot;&quot;*********************** 4 audio moments per bin ********************&quot;&quot;&quot;</span> 
    <span class="n">MEANt_per_bin</span><span class="p">,</span> <span class="n">VARt_per_bin</span><span class="p">,</span> <span class="n">SKEWt_per_bin</span><span class="p">,</span> <span class="n">KURTt_per_bin</span> <span class="o">=</span> <span class="n">spectral_moments</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">MEANt_per_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">MEANt_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">VARt_per_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">VARt_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">SKEWt_per_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">SKEWt_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">KURTt_per_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">KURTt_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">MEANt_per_bin</span><span class="p">,</span><span class="n">VARt_per_bin</span><span class="p">,</span>
                           <span class="n">SKEWt_per_bin</span><span class="p">,</span><span class="n">KURTt_per_bin</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;**************************** Number of peaks ************************&quot;&quot;&quot;</span>
    <span class="n">NBPEAKS</span> <span class="o">=</span> <span class="n">number_of_peaks</span><span class="p">(</span><span class="n">S_amplitude</span><span class="p">,</span><span class="n">fn</span><span class="p">,</span><span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">NBPEAKS</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NBPEAKS </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">NBPEAKS</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;********* total sound pressure level in frequency domain ************&quot;&quot;&quot;</span>
    <span class="n">LEQf</span><span class="p">,</span> <span class="n">LEQf_per_bin</span> <span class="o">=</span> <span class="n">spectral_leq</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">Vadc</span><span class="p">,</span> <span class="n">sensitivity</span><span class="p">,</span> <span class="n">dBref</span><span class="p">,</span> <span class="n">pRef</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">LEQf</span><span class="p">]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">LEQf_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LEQf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">LEQf</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;************ Signal to noise Ratio and noise energy   *************&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot; SNRf [TOWSEY] &quot;&quot;&quot;</span>
    <span class="n">ENRf</span><span class="p">,</span> <span class="n">BGNf</span><span class="p">,</span> <span class="n">SNRf</span><span class="p">,</span> <span class="n">ENRf_per_bin</span><span class="p">,</span> <span class="n">BGNf_per_bin</span><span class="p">,</span> <span class="n">SNRf_per_bin</span> <span class="o">=</span> <span class="n">spectral_snr</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ENRf</span><span class="p">,</span> <span class="n">BGNf</span><span class="p">,</span> <span class="n">SNRf</span><span class="p">]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ENRf_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">BGNf_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">SNRf_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ENRf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ENRf</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BGNf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">BGNf</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SNRf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">SNRf</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;*******************  energy concentration : entropy ****************&quot;&quot;&quot;</span>
    <span class="n">Hf</span><span class="p">,</span> <span class="n">Ht_per_bin</span> <span class="o">=</span> <span class="n">frequency_entropy</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span> <span class="n">compatibility</span><span class="o">=</span><span class="s2">&quot;QUT&quot;</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Hf</span><span class="p">]</span> 
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Ht_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hf </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">Hf</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;*********************** Remove stationnary noise ********************&quot;&quot;&quot;</span>       
    <span class="c1">#### Use median_equalizer function as it is fast reliable</span>
    <span class="n">Sxx_power_noNoise</span> <span class="o">=</span> <span class="n">median_equalizer</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    
    
    <span class="c1">#### Convert into dB</span>
    <span class="n">Sxx_dB_noNoise</span> <span class="o">=</span> <span class="n">power2dB</span><span class="p">(</span><span class="n">Sxx_power_noNoise</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;******** Spectral indices from Spectrum (Amplitude or Energy) *******&quot;&quot;&quot;</span>  
    <span class="sd">&quot;&quot;&quot; EAS, ECU, ECV, EPS, KURT, SKEW [TOWSEY]  &quot;&quot;&quot;</span>
    <span class="c1">#### Does not take into account low frequencies.</span>
    <span class="n">EAS</span><span class="p">,</span> <span class="n">ECU</span><span class="p">,</span> <span class="n">ECV</span><span class="p">,</span> <span class="n">EPS</span><span class="p">,</span> <span class="n">EPS_KURT</span><span class="p">,</span> <span class="n">EPS_SKEW</span> <span class="o">=</span> <span class="n">spectral_entropy</span> <span class="p">(</span><span class="n">Sxx_power_noNoise</span><span class="p">,</span>
                                                               <span class="n">fn</span><span class="p">,</span>
                                                               <span class="n">flim</span><span class="o">=</span><span class="p">(</span><span class="n">flim_mid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">flim_hi</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                                               <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">EAS</span><span class="p">,</span> <span class="n">ECU</span><span class="p">,</span> <span class="n">ECV</span><span class="p">,</span> <span class="n">EPS</span><span class="p">,</span> <span class="n">EPS_KURT</span><span class="p">,</span> <span class="n">EPS_SKEW</span><span class="p">]</span> 
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EAS </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">EAS</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ECU </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ECU</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ECV </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ECV</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EPS </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">EPS</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EPS_KURT </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">EPS_KURT</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EPS_SKEW </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">EPS_SKEW</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;=============================================================</span>
<span class="sd">    ECOLOGICAL INDICES :</span>
<span class="sd">            ACI</span>
<span class="sd">            NDSI </span>
<span class="sd">            rBA </span>
<span class="sd">            Bioacoustics Index</span>
<span class="sd">    =============================================================&quot;&quot;&quot;</span>
    
    <span class="c1">#### Acoustic complexity index =&gt; 1st derivative of the spectrogram</span>
    <span class="sd">&quot;&quot;&quot; ACI &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span><span class="n">ACI_per_bin</span><span class="p">,</span><span class="n">ACI_sum</span> <span class="o">=</span> <span class="n">acoustic_complexity_index</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">)</span>
    <span class="n">ACI</span><span class="o">=</span><span class="n">ACI_sum</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ACI</span><span class="p">]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ACI_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACI </span><span class="si">{seewave}</span><span class="s2"> </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">ACI</span><span class="p">)</span>

    <span class="c1">#### energy repartition in the frequency bins</span>
    <span class="sd">&quot;&quot;&quot; NDSI &amp; rBA &quot;&quot;&quot;</span>
    <span class="n">NDSI</span><span class="p">,</span> <span class="n">rBA</span><span class="p">,</span> <span class="n">AnthroEnergy</span><span class="p">,</span> <span class="n">BioEnergy</span> <span class="o">=</span> <span class="n">soundscape_index</span><span class="p">(</span><span class="n">Sxx_power</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> 
                                                         <span class="n">flim_bioPh</span><span class="o">=</span><span class="n">flim_mid</span><span class="p">,</span>
                                                         <span class="n">flim_antroPh</span><span class="o">=</span><span class="n">flim_low</span><span class="p">,</span>
                                                         <span class="n">R_compatible</span><span class="o">=</span><span class="n">R_compatible</span><span class="p">)</span> 
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">NDSI</span><span class="p">,</span> <span class="n">rBA</span><span class="p">,</span> <span class="n">AnthroEnergy</span><span class="p">,</span> <span class="n">BioEnergy</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>                                         
        <span class="k">if</span> <span class="n">R_compatible</span> <span class="o">==</span> <span class="s1">&#39;soundecology&#39;</span> <span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NDSI </span><span class="si">{soundecology}</span><span class="s2"> </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">NDSI</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NDSI </span><span class="si">{seewave}</span><span class="s2"> </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">NDSI</span><span class="p">)</span>
   
    <span class="c1">###### Bioacoustics Index : the calculation in R from soundecology is weird...</span>
    <span class="sd">&quot;&quot;&quot; BI &quot;&quot;&quot;</span>
    <span class="n">BI</span> <span class="o">=</span> <span class="n">bioacoustics_index</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> 
                           <span class="n">flim</span><span class="o">=</span><span class="n">flim_mid</span><span class="p">,</span> <span class="n">R_compatible</span><span class="o">=</span><span class="n">R_compatible</span><span class="p">)</span> 
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">BI</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">R_compatible</span> <span class="o">==</span> <span class="s1">&#39;soundecology&#39;</span> <span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BI </span><span class="si">{SoundEcology}</span><span class="s2"> </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">BI</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BI </span><span class="si">{MAAD}</span><span class="s2"> </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">BI</span><span class="p">)</span>
    
    <span class="c1">#### roughness</span>
    <span class="sd">&quot;&quot;&quot; ROU &quot;&quot;&quot;</span>
    <span class="n">ROU_per_bin</span> <span class="o">=</span> <span class="n">roughness</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ROU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ROU_per_bin</span><span class="p">)</span> 
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ROU</span><span class="p">]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ROU_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;roughness </span><span class="si">%2.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ROU</span><span class="p">)</span>    
    
    <span class="sd">&quot;&quot;&quot;*********** Spectral indices from the decibel spectrogram ***********&quot;&quot;&quot;</span>
    <span class="c1">#### Score</span>
    <span class="sd">&quot;&quot;&quot; ADI &amp; AEI &quot;&quot;&quot;</span> 
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        COMMENT :</span>
<span class="sd">                - threshold : -50dB when norm by the max (as soundecology)</span>
<span class="sd">                              6dB if PSDxxdB_SansNoise</span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="n">ADI</span> <span class="o">=</span> <span class="n">acoustic_diversity_index</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">flim_low</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                 <span class="n">fmax</span><span class="o">=</span><span class="n">flim_mid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_step</span><span class="o">=</span><span class="n">bin_step</span><span class="p">,</span> 
                                 <span class="n">dB_threshold</span><span class="o">=-</span><span class="mi">50</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s2">&quot;shannon&quot;</span><span class="p">)</span> 
    <span class="n">AEI</span> <span class="o">=</span> <span class="n">acoustic_eveness_index</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">flim_low</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                               <span class="n">fmax</span><span class="o">=</span><span class="n">flim_mid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_step</span><span class="o">=</span><span class="n">bin_step</span><span class="p">,</span> 
                               <span class="n">dB_threshold</span><span class="o">=-</span><span class="mi">50</span><span class="p">)</span> 
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ADI</span><span class="p">,</span> <span class="n">AEI</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ADI </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">ADI</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AEI </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">AEI</span><span class="p">)</span>
               
    <span class="sd">&quot;&quot;&quot;************************** SPECTRAL COVER ***************************&quot;&quot;&quot;</span>
    <span class="c1">#### frequency cover </span>
    <span class="sd">&quot;&quot;&quot; LFC, MFC, HFC [TOWSEY] &quot;&quot;&quot;</span>
    <span class="n">LFC</span><span class="p">,</span> <span class="n">MFC</span><span class="p">,</span> <span class="n">HFC</span> <span class="o">=</span> <span class="n">spectral_cover</span> <span class="p">(</span><span class="n">Sxx_dB_noNoise</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span><span class="n">dB_threshold</span><span class="o">=</span><span class="n">dB_threshold</span><span class="p">,</span> 
                                    <span class="n">flim_LF</span><span class="o">=</span><span class="n">flim_low</span><span class="p">,</span><span class="n">flim_MF</span><span class="o">=</span><span class="n">flim_mid</span><span class="p">,</span><span class="n">flim_HF</span><span class="o">=</span><span class="n">flim_hi</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">LFC</span><span class="p">,</span> <span class="n">MFC</span><span class="p">,</span> <span class="n">HFC</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LFC </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">LFC</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MFC </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">MFC</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;HFC </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">HFC</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;**************************** Activity *******************************&quot;&quot;&quot;</span>
    <span class="c1"># Time resolution (in s)</span>
    <span class="n">DELTA_T</span> <span class="o">=</span> <span class="n">tn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">rejectDuration</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">rejectDuration</span> <span class="o">=</span> <span class="n">DELTA_T</span> <span class="o">*</span> <span class="mi">3</span>
    
    <span class="n">X</span> <span class="o">=</span> <span class="n">Sxx_dB_noNoise</span>
    <span class="n">ACTspFract</span><span class="p">,</span> <span class="n">ACTspCount</span><span class="p">,</span> <span class="n">ACTspMean</span> <span class="o">=</span> <span class="n">spectral_activity</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dB_threshold</span><span class="o">=</span><span class="n">dB_threshold</span><span class="p">)</span>
    <span class="n">ACTspFract_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ACTspFract</span><span class="p">)</span>
    <span class="n">ACTspCount_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ACTspCount</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ACTspFract_avg</span><span class="p">,</span> <span class="n">ACTspCount_avg</span><span class="p">,</span> <span class="n">ACTspMean</span><span class="p">]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ACTspFract</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ACTspCount</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACTspFract </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">ACTspFract_avg</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACTspCount </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">ACTspCount_avg</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACTspMean </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">ACTspMean</span><span class="p">)</span>

    <span class="n">EVNspFract</span><span class="p">,</span> <span class="n">EVNspMean</span><span class="p">,</span> <span class="n">EVNspCount</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spectral_events</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> 
                                                            <span class="n">dt</span><span class="o">=</span><span class="n">DELTA_T</span><span class="p">,</span>
                                                            <span class="n">dB_threshold</span><span class="o">=</span><span class="n">dB_threshold</span><span class="p">,</span>
                                                            <span class="n">rejectDuration</span><span class="o">=</span><span class="n">rejectDuration</span><span class="p">,</span>
                                                            <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">EVNspFract_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">EVNspFract</span><span class="p">)</span>
    <span class="n">EVNspMean_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">EVNspMean</span><span class="p">)</span>
    <span class="n">EVNspCount_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">EVNspCount</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">EVNspFract_avg</span><span class="p">,</span> <span class="n">EVNspMean_avg</span><span class="p">,</span> <span class="n">EVNspCount_avg</span><span class="p">]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EVNspFract</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EVNspMean</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">EVNspCount</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EVNspFract </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">mean</span><span class="p">(</span><span class="n">EVNspFract</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EVNspMean </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">mean</span><span class="p">(</span><span class="n">EVNspMean</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EVNspCount </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">mean</span><span class="p">(</span><span class="n">EVNspCount</span><span class="p">))</span>
          
    <span class="sd">&quot;&quot;&quot;**************************** New indices*****************************&quot;&quot;&quot;</span> 
    <span class="sd">&quot;&quot;&quot; TFSD &quot;&quot;&quot;</span>
    <span class="c1"># compute TFSD with mode = ThirdOctave and flim</span>
    <span class="n">TFSD</span><span class="o">=</span> <span class="n">tfsd</span><span class="p">(</span><span class="n">Sxx_amplitude</span><span class="p">,</span><span class="n">fn</span><span class="p">,</span><span class="n">tn</span><span class="p">,</span><span class="n">flim</span><span class="o">=</span><span class="n">flim_mid</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;thirdOctave&#39;</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">TFSD</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;TFSD </span><span class="si">%2.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">TFSD</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot; More entropy&quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">S_power</span>
    <span class="n">H_Havrda</span><span class="p">,</span> <span class="n">H_Renyi</span><span class="p">,</span> <span class="n">H_pairedShannon</span><span class="p">,</span> <span class="n">H_gamma</span><span class="p">,</span> <span class="n">H_GiniSimpson</span> <span class="o">=</span> <span class="n">more_entropy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">H_Havrda</span><span class="p">,</span> <span class="n">H_Renyi</span><span class="p">,</span> <span class="n">H_pairedShannon</span><span class="p">,</span> <span class="n">H_gamma</span><span class="p">,</span> <span class="n">H_GiniSimpson</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H_Havrda </span><span class="si">%2.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">H_Havrda</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H_Renyi </span><span class="si">%2.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">H_Renyi</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H_pairedShannon </span><span class="si">%2.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">H_pairedShannon</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H_gamma </span><span class="si">%2.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">H_gamma</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;H_GiniSimpson </span><span class="si">%2.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">H_GiniSimpson</span><span class="p">)</span>  

    <span class="sd">&quot;&quot;&quot; RAOQ &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">S_power</span>
    <span class="n">RAOQ</span> <span class="o">=</span> <span class="n">frequency_raoq</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="n">bin_step</span><span class="p">)</span> 
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">RAOQ</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RAOQ </span><span class="si">%2.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">RAOQ</span><span class="p">)</span>
    
    <span class="c1">#### Acoustic gradient index =&gt; real 1st derivative of the spectrogram</span>
    <span class="sd">&quot;&quot;&quot; AGI &quot;&quot;&quot;</span>
    <span class="c1"># Time resolution (in s)</span>
    <span class="n">DELTA_T</span> <span class="o">=</span> <span class="n">tn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">Sxx_amplitude</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">AGI_per_bin</span><span class="p">,</span> <span class="n">AGI</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">acoustic_gradient_index</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">DELTA_T</span><span class="p">,</span> 
                                                   <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;per_bin&#39;</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">AGI</span><span class="p">]</span>
    <span class="n">df_per_bin_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">AGI_per_bin</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AGI </span><span class="si">%2.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">AGI</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot; ROI index &quot;&quot;&quot;</span>
    <span class="c1"># Time resolution (in s)</span>
    <span class="n">DELTA_T</span> <span class="o">=</span> <span class="n">tn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Frequency resolution (in Hz)</span>
    <span class="n">DELTA_F</span> <span class="o">=</span> <span class="n">fn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">fn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Minimum time duration of an event (in s)</span>
    <span class="n">MIN_EVENT_DUR</span> <span class="o">=</span> <span class="mf">30e-3</span>
    <span class="c1"># Minimum frequency bandwidth (in Hz)</span>
    <span class="n">MIN_FREQ_BW</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="c1"># Min Region Of Interest ROI</span>
    <span class="k">if</span> <span class="n">min_roi_area</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
        <span class="n">min_roi_area</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">MIN_EVENT_DUR</span><span class="o">/</span><span class="n">DELTA_T</span> <span class="o">*</span> <span class="n">MIN_FREQ_BW</span> <span class="o">/</span> <span class="n">DELTA_F</span><span class="p">)</span>
    <span class="n">ROItotal</span><span class="p">,</span> <span class="n">ROIcover</span> <span class="o">=</span> <span class="n">region_of_interest_index</span><span class="p">(</span><span class="n">Sxx_dB_noNoise</span><span class="p">,</span> 
                                               <span class="n">tn</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> 
                                               <span class="n">smooth_param1</span><span class="p">,</span> 
                                               <span class="n">mask_mode</span><span class="p">,</span>
                                               <span class="n">mask_param1</span><span class="p">,</span> 
                                               <span class="n">mask_param2</span><span class="p">,</span> 
                                               <span class="n">min_roi</span><span class="o">=</span><span class="n">min_roi_area</span><span class="p">,</span> 
                                               <span class="n">remove_rain</span> <span class="o">=</span> <span class="n">remove_rain</span><span class="p">,</span>
                                               <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">)</span>
    <span class="n">df_spectral_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ROItotal</span><span class="p">,</span> <span class="n">ROIcover</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ROItotal </span><span class="si">%2.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ROItotal</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ROIcover </span><span class="si">%2.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ROIcover</span><span class="p">)</span>
        
    <span class="n">df_spectral_indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">df_spectral_indices</span><span class="p">],</span> 
                                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;MEANf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;VARf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;SKEWf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;KURTf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;NBPEAKS&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;LEQf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;ENRf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;BGNf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;SNRf&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;Hf&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;EAS&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ECU&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ECV&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;EPS&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;EPS_KURT&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;EPS_SKEW&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ACI&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;NDSI&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;rBA&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;AnthroEnergy&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;BioEnergy&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;BI&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ROU&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ADI&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;AEI&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;LFC&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;MFC&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;HFC&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ACTspFract&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ACTspCount&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ACTspMean&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;EVNspFract&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;EVNspMean&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;EVNspCount&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;TFSD&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;H_Havrda&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;H_Renyi&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;H_pairedShannon&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;H_gamma&#39;</span><span class="p">,</span> 
                                             <span class="s1">&#39;H_GiniSimpson&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;RAOQ&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;AGI&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ROItotal&#39;</span><span class="p">,</span>
                                             <span class="s1">&#39;ROIcover&#39;</span><span class="p">])</span>
        
    <span class="n">df_per_bin_indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">df_per_bin_indices</span><span class="p">],</span> 
                                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;frequencies&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;LTS&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;MEANt_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;VARt_per_bin&#39;</span><span class="p">,</span> 
                                            <span class="s1">&#39;SKEWt_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;KURTt_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;LEQf_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;ENRf_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;BGNf_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;SNRf_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;Ht_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;ACI_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;ROU_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;ACTspFract_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;ACTspCount_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;EVNspFract_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;EVNspMean_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;EVNspCount_per_bin&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;AGI_per_bin&#39;</span><span class="p">])</span>
                                    
    <span class="k">return</span> <span class="n">df_spectral_indices</span><span class="p">,</span> <span class="n">df_per_bin_indices</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, scikit-maad development team.

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    

  <style>
         .wy-nav-content { max-width: none; }
  </style>



</body>
</html>